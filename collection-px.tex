%% White space:
%% sentence parts on separate lines

% TODO: add review
\documentclass[sigconf, 10pt]{acmart}
%\documentclass[sigconf, 10pt, review]{acmart}
% \documentclass[sigconf, 10pt, authordraft]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\def\Title{Small and Versatile vs. Large and Specialized}
% \def\ShortTitle{}
\def\SubTitle{How to design a collection library for exploratory programming?}
\def\PdfTitle{\Title: \SubTitle}
\def\PdfSubject{TODO}
\def\PdfAuthors{{Stefan Marr, Benoit Daloze}}
\def\PdfKeywords{TODO}

\def\SOMns{SOM{\sc ns}\xspace}

\include{scripts/init}


\collabAuthor{bd}{green!60!black}{Benoit}
\collabAuthor{sm}{red}{Stefan}

\usepackage{booktabs} % For formal tables

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\acmDOI{10.475/123_4} % TODO
\acmISBN{123-4567-24-567/08/06} % TODO

%Conference
\acmConference[PX/18]{Programming Experience Workshop}{April 2018}{Nice, France}
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{15.00}
\acmSubmissionID{123-A12-B3}

\begin{document}
\title{\Title}
% \titlenote{Produces the permission block, and
%   copyright information}
\subtitle{\SubTitle}
% \subtitlenote{The full version of the author's guide is available as
%   \texttt{acmart.pdf} document}

\author{Stefan Marr}
\orcid{0000-0001-9059-5180}
\affiliation{%
    \department{School of Computing}
    \institution{University of Kent}
    \city{Canterbury}
    \postcode{CT2 7NZ}
    \country{United Kingdom}
}
\email{s.marr@kent.ac.uk}

\author{Benoit Daloze}
\affiliation{%
    \department{Institute for System Software}
    \institution{Johannes Kepler University Linz}
    \streetaddress{Altenbergerstra√üe, 69}
    \city{Linz}
    \postcode{4040}
    \country{Austria}
}
\email{benoit.daloze@jku.at}


% The default list of authors is too long for headers.
% \renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}


\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
% TODO
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

% TODO
\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% TODO
\keywords{Collection Libraries, Design, Implementation, Exploratory Programming}

\maketitle


\section{Collections for Exploratory Programming}

% Context: What is the broad context of the work? What is the importance of the general research area?
% - collection libraries
%   essential part of any general purpose language
%   - C doesn't have one?

One of the basic concepts of programming languages are collections or containers, i.e.,
data structures that abstract over the number of data items
and allow operations over the contained items as a whole or individually.
As such, they are a fundamental aspect of general purpose languages.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?

The design of collection libraries varies greatly between languages,
and sometimes there are even multiple libraries
to facilitate different programming styles, application scenarios, or performance requirements.
They can range from having only arrays,
as the exclusive basic abstraction as in C,
to systems such as Java,
where the standard library includes hundreds of collection abstractions.
% - library design has major influence on
%   - language style/idioms
%   - programmer productivity (assumed)
%   - feeling of the language
% - as far as we are aware no systematic study
To the best of our knowledge,
there is not systemic study on how the design of a collection library
influences programmer productivity
or a language's suitability for exploratory programming.

% Approach: What was done that unveiled new knowledge?
% - explore design space
%   - which aspects need to be considered
%   - which design dimensions are there
The goal of this study is to identify the aspects
that need to be considered for the design of collection libraries
for exploratory and live programming.
%
%
% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
%- reason about design space for a language designed for exploration
% - high flexibility
% - low friction
%   - avoid making unnecessary decisions,
%   - performance not important
%   - problem first needs to be understood
% - interactive program development
% -> live programming
Thus, we reason about the design space for collections
and how different design choices may influence the programming experience.
We focus specifically on how different design choices relate to the main
programming task\sm{avoid making unnecessary decisions}, performance, and the liveness of the programming experience\sm{feedback potential}.

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
%- argue for feasibility based on existing techniques
In order to get an overview of the design space,
we discuss the high-level design of collection libraries for
\smtodo{add list of languages}, Java, JavaScript, Python, and Ruby.
From this overview, we extract the concrete design dimensions
and present arguments for and against design choices
in the context of exploratory programming.
Finally, we review implementation techniques
to judge whether design choices can be practical
in terms of achieving the same performance as alternative choices.

Therefore, this paper\sm{somewhat a contribution statement, but also redundant with the above. Revisit before submission.}

\begin{itemize}
  \item describes the design space for collection libraries
  \item discusses design choices and their suitability for exploratory programming
  \item reviews implementation techniques to ensure practical performance
\end{itemize}

% Importance: Why does this work matter?
% - collections are complex but essential parts of our languages
%   - better understanding will enable more principled design
We hope this analysis provides an insight
into the complex design space of collection libraries
and their relation to the programming experience itself.
Our immediate goal was to better understand the tension between design choices
for the design of a collection library for \SOMns, a Newspeak implementation\citep{Bracha:10:NS,OptCELWithTruffle}.
Newspeak follows in many ways previous Smalltalk systems
and as such has a large and specialized collection library.
However, based on the arguments presented here,
we believe that a small and versatile library would a more suitable design
for a language as dynamic and \ugh{aimed at exploratory programming} as Newspeak.\sm{not sure about this bit, need to think about it}


\section{Background: Live and Exploratory Programming}

Before diving into the details of designing collection libraries,
we discuss the terms live and exploratory programming
to clarify our assumptions and the context of this analysis.

% - need a brief discussion of what our assumptions are
% - what are the ``requirements''?
% - four levels: \citep{Tanimoto:1990:Viva,Tanimoto:2013:PEL}
%   level 3:
%    - changes update programs
%      -> system might attempt reexecution, possibly only relevant parts
%   level 4:
%    - continuous feedback in time-varying results based on current program

For the term \emph{live programming}, we will rely on \citeauthor{Tanimoto:1990:Viva}'s notion.
Specifically, our aim is to support programming that is supported
by immediate updates and feedback from the programming environment.
This might be either triggered by edits or presented as continuous event streams,
which corresponds to liveness of level 3 or 4\citep{Tanimoto:1990:Viva}.
While generally desirable, we forgo considering more advanced liveness levels
that include predictive features, \ie, level 5 and 6\citep{Tanimoto:2013:PEL}.

%  - feedback on valid programs
%  - feedback on execution
Based on these liveness level and on the work of others\citep{McDirmid:2007:LUL,Burckhardt:2013:ACF,Rein:2016:LLP},
we expect programming environments and languages
to improve the programming experience by providing immediate feedback on
the validity of programs and code execution.
This feedback should be meant to reduce the friction
that is inherent in the communication between humans and machines,
which is constrained by artificial languages and machines
that still neither perceive the context of a conversation nor learn from interaction.
To work around these limitations in our communication,
we expect machines to support the communication with feedback,
limited forms of understanding,
and a basic robustness to invalid communication.

%% Feedback
% - want feedback on valid operations in terms of
Feedback should be provided in form of
%   - code completion, documentation
code completion, contextual documentation,
%   - error highlighting (unsupported methods)
syntax errors, possibly invalid method calls or operations,
and style errors or undesirable patterns.
% - edit/feedback latency
%   - feedback should be fast, overall execution fast enough
% - state snapshots, reexecution, redisplay
% - should not prevent state snapshots (seems orthogonal)
% - possibility of continuous feedback
%   (seems to be orthogonal, but should not be prevented)
The analyses that enable such feedback need to be implementable
in an efficient manner to give the illusion of instantaneous feedback.
%
%% Understanding
% - implicit over explicit, for types
%   - types inferred or dynamic
With limited forms of understanding,
we refer essentially to analyses
that allow programmers to be more implicit than explicit in their programming.
One aspect of this is typing.
Traditionally, languages that use type inference
or tool-based feedback seem to facilitate exploratory programming better
than languages that require us to make such aspect explicit.
%   
%% Robustness
% - error recovery, robustness, non-interference of irrelevant parts
% - program errors in unrelated/unexecuted parts need to be ignored
The overall system should also be robust with respect to programming errors.
Especially errors in unrelated program parts,
or parts that are not actually executed
should not inhibit our ability to interact with the system,
explore and extend it.

%% 
Generally, when exploring a problem and experimenting with solutions,
we want to focus on the problem domain and prioritize the core aspects
while deferring for instance overall application performance,
handling of exceptional cases,
or the completeness of a solution to a later point.
Thus, the programming environment should not force us to make decisions,
which we cannot yet make because of our incomplete understanding of the problem
or inaccurate predictions of how an algorithm is used in production scenarios.
Types or structural elements often help exploring
the problem and organizing thoughts,
but should not prevent or hinder us from exploring it.

% - focus decision making on problem and domain
%   - application performance secondary concern,
%    as long as feedback is not impaired 
% - types or at least structure might still be helpful to organize ones thoughts
Since collections are frequently used for bulk operations
that might end up being relevant for acceptable performance,
run-time performance is a relevant aspect and needs to be considered.
While it is not of highest priority for application performance,
it should also not impede live feedback.

\section{Collection Libraries in the Wild, A Brief Excursion}

\begin{note}
- having a brief look around, informally, just getting a flavor
 - what collections do they contain
 - how large (num classes/concepts) are libraries
 - any particularly interesting things?

- C
 - array
- C++
 - sequences
  - array, vector, deque, forward_list (singly linked list), list (double)

 - associative
  - set, map
  - also unordered

 - adapters
   - stack, queue

boost C++
 - expands with specialized containers,
   mostly specific to C++ language constrains
   - and different representation tradeoffs
   - different vector classes (stable, static, small)
   - flat sets/maps (instead of using trees)
     - worse at insertion but faster lookup
   - heap (priority queues)
   - collections packing objects by type (for performance) PolyCollection
 -> indicates that here performance is main driver for variability
\url{http://www.boost.org/doc/libs/1_66_0/doc/html/}

- Java
 - map, list, set, deque
 - hash map/set, tree map/set
 - lists: linked, array
 - stack, priority queue
 - skip list, CopyOnWriteArrayList
 - ordered collections
   - navigable collections
 - weak collections
 - concurrent collections
 - identity hashmap
 - readonly/unmodifiable collections

- Go
 - arrays, slices, maps
 - heap, list, ring
 - no sets


- Guava
 - extension, keeps compatibility and set of concepts (for many elements)
 - immutable collections (more optimized over unmodifiable)
 - multiset, multimap, bimap, table (2 nested maps),
 - RangeSet, RangeMap
 \url{https://github.com/google/guava/wiki/CollectionUtilitiesExplained}
 - iterators

- Goldman Sachs Collections, now Eclipse Collections
  \url{https://www.eclipse.org/collections/} %\citeurl
   - extension, keeps compatibility and set of concepts (for many elements)
   - BiMap, Bag, Multimap
   - mutable and immutable collections
   - specializations for primitive types
   - rich iteration operation, incl. lazy and parallel iteration

- C\#
 - ArrayList, BitArray, Dictionary (hashtable), queue, stack, HashSet,
   LinkedList
 - ordered collections
 - concurrent collections
 - read only collections
 - iterators, query support

  
  - Scala
    - has collection framework with mutable and immutable collections
      -> do they have the same structure?
      -> are immutable collections always persistent?
      -> are APIs adapted to facilitate different style?
        -> perhaps not necessary since Scala embraces FP
    - uniform return type principle \smtodo{was this in \citet{Odersky:2009}?} \url{https://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html} 
     The Architecture of Scala Collections  
  

- Ruby, JavaScript, Python

- Dart, Smalltalk, Lisp

- Eiffel, Pascal, Ada, ... other old-school stuff
- Oz, Prolog, Erlang, ... 

- Haskell, ML, Ocam, Ocaml, ...
- other unconventional languages





- which collections are actually used?
 -> \code{ArrayList} overwhelmingly so with 47\% of all collections
    Then come \code{HashMap} at 23\% and \code{HashSet} with 10\% \citep{Costa:2017:ESU} 
    - everything else is 
 -> \citet[sec. 9.2]{Bergel:2018} report that \code{OrderedCollection} and \code{Dictionary} are the frequently used collections in some Pharo.
 While the study is less comprehensive than the Java one, it confirms the general trend. Interestingly, it also considers arrays and find that they are used slightly more than \code{Dictionary}.



\end{note}

\section{Design Dimensions for Collection Libraries}

\begin{note}
  - language style
    - object-oriented, procedural, functional, ...
  
  - mutability (mutable, immutable)
  - persistence (persistent data structures, just an implementation technique for immutable collections? or does it have a design impact? probably, because of performance aspects)
  - bulk operation
    - order guarantees (everything modeled as lists)
    - processing (sequential, parallel, lazy)
    - slices
    - internal/external iteration
  - polymorphism 
    - compatibility of collections
      - maps as lists (iteration), lists as maps (int->T maps)

  - Generalization vs. Specialization  
  - small set of generalized collection types 
  - or large set of specialized types
  
  - is small and versatile bad design because it violates the `one thing does   one thing good premise'
    - are those classes blobs? \citep{brown1998antipatterns}
    - do they do too much? is this an issue?
     -> yes, it's an issue, the code is not clear about what kind of 
        interactions one wants to allow on the collection
     -> complexity of implementation is a real issue (concurrency issues,
        strategies, JIT DS...)
     -> this means, it can be a burden for maintaining large systems
     -> it is a burden for VM maintenance
     -> however, The Blob anti-pattern combines complex state and behavior
        such collection design is not a direct instance of it, because
        the contained data is usually still used for a single purpose and
        it is merely that the collections themselves offer too much
        functionality

    - benefits of specialized classes:
      - chose specific implementation/algorithm/data structure
      - some people argue that programs are better understood if these things are explicit: \citep{PeytonJones:1996:BTC}
        -> """The type of the object does not specify its invariant (\eg in a set there are no duplicates) and its expected operations (\eg lookup in a infinite map). The lack of these invariants makes the program harder to understand, harder to prove properties about, and harder to maintain."""
        -> generic data structures (lists in case of Haskell) might not be optimal
         -> PJ already talks about 2.3 Adaptive representations
         A probabilistic approach to the problem of automatic selection of data representations \citep{Chuang:1996:PAP}
          -> markov processes

      - example
        -> set/map: implemented as tree or hash table?
        -> linked list or array list, or linked segments?
        -> can't make a right choice without knowing exactly what
           run time load is going to be

    - drawback of too specialized classes:
      - can become inflexible
        -> need conversion or adapters to perform certain operations
        -> large class hierarchies, hard to chose one, might not even be
           clear what options are available, or appropriate for problem
     

- target language
 - abstractions present in the underlying language influence design
   -> typed languages
     -> expressiveness of type system might restrict or guide the shape
        of the library
     -> can have influence on aspects such as code duplication etc
     -> Scala experience paper as example
     -> template in C++ different in expressive power and constraints
     -> Haskell and other languages compared \citep{Garcia:2007}
       -> sometimes language might need to evolve to enable the desired design \citep{Chakravarty:2005:ATC} \citep{Black:2003:ATS} (see below, need to structure this correspondingly)
       
  -> code reuse and structure
    -> available language mechanism shape the library
    -> or lead to suboptimal designs
     -> Smalltalk example \citep{Cook:1992:ISS}
       -> if you only got single inheritance, only mechanism of reuse
          that does not need composition (which might introduce other issues,
          for instance performance overhead in interpreted languages)
       -> subclassing not always ideal
       -> some things are just not subclasses
         -> deleting methods
         -> providing other functionality via same name
         -> structuring request much care
         
       
  
\end{note}


\section{Techniques for Efficient Implementations}


\begin{note}
  what is required in terms of efficiency?
  compilation-time feedback - needs to be fast to compile
  run-time performance - needs to be fast to execute

  \citep{Rein:2016:LLP} should look a little more into this one for terminology
  
Discussion Points:
 
Practical Implementation Concerns
 How to realize all this with same efficiency as when using special purpose
 collections?
 - probably not getting there 100\%, but 90\% or even 80\% are sufficient
   when it improves developer productivity (which still has to be proven of course)
  
 - to get to the 80-90\% mark
  -> strategies (seq, par)
   - Storage strategies for collections in dynamically typed languages \citep{Bolz:2013:SSC}
   -> concurrency strategy paper
  -> JIT Data Structures
     -> the other paper about collections I saw (something from a german university)

  -> CollectionSwitch: A Framework for Efficient and Dynamic Collection Selection
DOI 10.1145/3168825
CGO 2018 (to appear)
  -> cameleon, ... (JIT DS references)
% \url{https://www.researchgate.net/publication/322438185_CollectionSwitch_A_Framework_for_Efficient_and_Dynamic_Collection_Selection

- Tobias Pape's paper, for functional data structures


- compiler for static languages can do certain optimizations ahead of time:
  - compiler-level specialization as with miniboxing \citep{Ureche:2013:MIS}
  - C++ templates (expanding ones), eager specialization

How to design so that specialized collections remain possible?
And are easily adopted?
 -> ensure subset of collection APIs are polymorphic
   -> ideally, one just changes the constructor, or adds a conversion
   -> idea would be that this gives the last 10-20\% of performance when needed
   -> leave door open for improving performance by restricting flexibility
\end{note}


\section{Related Work}
\sm{not sure we need this section}

\citet{Odersky:2009} describe their experience
redesigning the collection library in Scala.
Their focus is mostly on how they achieved an implementation and design
that is more principled, structured, and avoids code duplication
to avoid bit rot during future maintenance.
The library itself falls into the category of large and specialized (cf. \cref{sec:scala-col}). 

\citet{Matthes:2000:BT} investigate the question of how to design \emph{bulk types}, i.e., collection libraries, on the intersection to database systems and database programming languages.
They discuss the benefits and drawbacks of builtin or library-based designs and favor library-based designs for their extensibility.
\sm{discussion in paper context: assume we have good knowledge from the various languages and libraries what is necessary, assume that extensibility is not a problem either, because the languages could be dynamic and therefore lent itself naturally to simply changing the collection implementation if required.
Though, there might be limitations to what can be changed without interfering with optimizations such as strategies\todoref{}.}


Live Data Structure Programming \citep{Oka:2017:LDS}
- visualization
- generic data structures

\section{Conclusion}

C has the most minimal collection library, 


While I have convinced myself
that I do prefer the programming style offered
by a small and versatile collections library,
I cannot shake the feeling
that this is a post hoc justification
for the complexity we add to VMs.


%% ATTIC, Notes on Things Considered, but not included
%% ===================================================

%% Streams
%%
%% finite, or infinite sequence of values
%% aren't collections, just one way to express iteration/transformation

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
