%% White space:
%% sentence parts on separate lines

% TODO: add review
\documentclass[sigconf, 10pt]{acmart}
%\documentclass[sigconf, 10pt, review]{acmart}
% \documentclass[sigconf, 10pt, authordraft]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\def\Title{Small and Versatile vs. Large and Specialized}
% \def\ShortTitle{}
\def\SubTitle{How to design a collection library for exploratory programming?}
\def\PdfTitle{\Title: \SubTitle}
\def\PdfSubject{TODO}
\def\PdfAuthors{{Stefan Marr, Benoit Daloze}}
\def\PdfKeywords{TODO}

\def\SOMns{SOM{\sc ns}\xspace}

\include{scripts/init}


\collabAuthor{bd}{green!60!black}{Benoit}
\collabAuthor{sm}{red}{Stefan}

\usepackage{booktabs} % For formal tables

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\acmDOI{10.475/123_4} % TODO
\acmISBN{123-4567-24-567/08/06} % TODO

%Conference
\acmConference[PX/18]{Programming Experience Workshop}{April 2018}{Nice, France}
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{15.00}
\acmSubmissionID{123-A12-B3}

\begin{document}
\title{\Title}
% \titlenote{Produces the permission block, and
%   copyright information}
\subtitle{\SubTitle}
% \subtitlenote{The full version of the author's guide is available as
%   \texttt{acmart.pdf} document}

\author{Stefan Marr}
\orcid{0000-0001-9059-5180}
\affiliation{%
    \department{School of Computing}
    \institution{University of Kent}
    \city{Canterbury}
    \postcode{CT2 7NZ}
    \country{United Kingdom}
}
\email{s.marr@kent.ac.uk}

\author{Benoit Daloze}
\affiliation{%
    \department{Institute for System Software}
    \institution{Johannes Kepler University Linz}
    \streetaddress{Altenbergerstra√üe, 69}
    \city{Linz}
    \postcode{4040}
    \country{Austria}
}
\email{benoit.daloze@jku.at}


% The default list of authors is too long for headers.
% \renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}


\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
% TODO
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

% TODO
\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% TODO
\keywords{Collection Libraries, Design, Implementation, Exploratory Programming}

\maketitle


\section{Collections for Exploratory Programming}

% Context: What is the broad context of the work? What is the importance of the general research area?
% - collection libraries
%   essential part of any general purpose language
%   - C doesn't have one?

One of the basic concepts of programming languages are collections or containers, i.e.,
data structures that abstract over the number of data items
and allow operations over the contained items as a whole or individually.
As such, they are a fundamental aspect of general purpose languages.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?

The design of collection libraries varies greatly between languages,
and sometimes there are even multiple libraries
to facilitate different programming styles, application scenarios, or performance requirements.
They can range from having only arrays,
as the exclusive basic abstraction as in C,
to systems such as Java,
where the standard library includes dozens of collection abstractions.
% - library design has major influence on
%   - language style/idioms
%   - programmer productivity (assumed)
%   - feeling of the language
% - as far as we are aware no systematic study
To the best of our knowledge,
there is not systemic study on how the design of a collection library
influences programmer productivity
or a language's suitability for exploratory programming.

% Approach: What was done that unveiled new knowledge?
% - explore design space
%   - which aspects need to be considered
%   - which design dimensions are there
The goal of this study is to identify the aspects
that need to be considered for the design of collection libraries
for exploratory and live programming.
%
%
% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
%- reason about design space for a language designed for exploration
% - high flexibility
% - low friction
%   - avoid making unnecessary decisions,
%   - performance not important
%   - problem first needs to be understood
% - interactive program development
% -> live programming
Thus, we reason about the design space for collections
and how different design choices may influence the programming experience.
We focus specifically on how different design choices relate to the main
programming task\sm{avoid making unnecessary decisions}, performance, and the liveness of the programming experience\sm{feedback potential}.

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
%- argue for feasibility based on existing techniques
In order to get an overview of the design space,
we discuss the high-level design of collection libraries for
\smtodo{add list of languages}, Java, JavaScript, Python, and Ruby.
From this overview, we extract the concrete design dimensions
and present arguments for and against design choices
in the context of exploratory programming.
Finally, we review implementation techniques
to judge whether design choices can be practical
in terms of achieving the same performance as alternative choices.

Therefore, this paper\sm{somewhat a contribution statement, but also redundant with the above. Revisit before submission.}

\begin{itemize}
  \item describes the design space for collection libraries
  \item discusses design choices and their suitability for exploratory programming
  \item reviews implementation techniques to ensure practical performance
\end{itemize}

% Importance: Why does this work matter?
% - collections are complex but essential parts of our languages
%   - better understanding will enable more principled design
We hope this analysis provides an insight
into the complex design space of collection libraries
and their relation to the programming experience itself.
Our immediate goal was to better understand the tension between design choices
for the design of a collection library for \SOMns, a Newspeak implementation\citep{Bracha:10:NS,OptCELWithTruffle}.
Newspeak follows in many ways previous Smalltalk systems
and as such has a large and specialized collection library.
However, based on the arguments presented here,
we believe that a small and versatile library would a more suitable design
for a language as dynamic and \ugh{aimed at exploratory programming} as Newspeak.\sm{not sure about this bit, need to think about it}


\section{Live and Exploratory Programming}

Before diving into the details of designing collection libraries,
we discuss the terms live and exploratory programming
to clarify our assumptions and the context of this analysis.

% - need a brief discussion of what our assumptions are
% - what are the ``requirements''?
% - four levels: \citep{Tanimoto:1990:Viva,Tanimoto:2013:PEL}
%   level 3:
%    - changes update programs
%      -> system might attempt reexecution, possibly only relevant parts
%   level 4:
%    - continuous feedback in time-varying results based on current program

For the term \emph{live programming}, we will rely on \citeauthor{Tanimoto:1990:Viva}'s notion.
Specifically, our aim is to support programming that is supported
by immediate updates and feedback from the programming environment.
This might be either triggered by edits or presented as continuous event streams,
which corresponds to liveness of level 3 or 4\citep{Tanimoto:1990:Viva}.
While generally desirable, we forgo considering more advanced liveness levels
that include predictive features, \ie, level 5 and 6\citep{Tanimoto:2013:PEL}.

%  - feedback on valid programs
%  - feedback on execution
Based on these liveness level and on the work of others\citep{McDirmid:2007:LUL,Burckhardt:2013:ACF,Rein:2016:LLP},
we expect programming environments and languages
to improve the programming experience by providing immediate feedback on
the validity of programs and code execution.
This feedback should be meant to reduce the friction
that is inherent in the communication between humans and machines,
which is constrained by artificial languages and machines
that still neither perceive the context of a conversation nor learn from interaction.
To work around these limitations in our communication,
we expect machines to support the communication with feedback,
limited forms of understanding,
and a basic robustness to invalid communication.

%% Feedback
% - want feedback on valid operations in terms of
Feedback should be provided in form of
%   - code completion, documentation
code completion, contextual documentation,
%   - error highlighting (unsupported methods)
syntax errors, possibly invalid method calls or operations,
and style errors or undesirable patterns.
% - edit/feedback latency
%   - feedback should be fast, overall execution fast enough
% - state snapshots, reexecution, redisplay
% - should not prevent state snapshots (seems orthogonal)
% - possibility of continuous feedback
%   (seems to be orthogonal, but should not be prevented)
The analyses that enable such feedback need to be implementable
in an efficient manner to give the illusion of instantaneous feedback.
%
%% Understanding
% - implicit over explicit, for types
%   - types inferred or dynamic
With limited forms of understanding,
we refer essentially to analyses
that allow programmers to be more implicit than explicit in their programming.
One aspect of this is typing.
Traditionally, languages that use type inference
or tool-based feedback seem to facilitate exploratory programming better
than languages that require us to make such aspect explicit.
%   
%% Robustness
% - error recovery, robustness, non-interference of irrelevant parts
% - program errors in unrelated/unexecuted parts need to be ignored
The overall system should also be robust with respect to programming errors.
Especially errors in unrelated program parts,
or parts that are not actually executed
should not inhibit our ability to interact with the system,
explore and extend it.

%% 
Generally, when exploring a problem and experimenting with solutions,
we want to focus on the problem domain and prioritize the core aspects
while deferring for instance overall application performance,
handling of exceptional cases,
or the completeness of a solution to a later point.
Thus, the programming environment should not force us to make decisions,
which we cannot yet make because of our incomplete understanding of the problem
or inaccurate predictions of how an algorithm is used in production scenarios.
Types or structural elements often help exploring
the problem and organizing thoughts,
but should not prevent or hinder us from exploring it.

% - focus decision making on problem and domain
%   - application performance secondary concern,
%    as long as feedback is not impaired 
% - types or at least structure might still be helpful to organize ones thoughts
Since collections are frequently used for bulk operations
that might end up being relevant for acceptable performance,
run-time performance is a relevant aspect and needs to be considered.
While it is not of highest priority for application performance,
it should also not impede live feedback.

\section{Collection Design in the Wild}
\label{sec:col-wild}

% - having a brief look around, informally, just getting a flavor
%  - what collections do they contain
%  - how large (num classes/concepts) are libraries
%  - any particularly interesting things?

Collection library design seems to be as diverse as languages are different.
There is a multitude of design dimensions that can be varied.
Some of them are influenced by the underlying language,
its basic abstractions,
as well as what is considered desirable programming style, \ie, idiomatic code.
Other dimensions include the set of offered collection types,
implementation strategies (usually differing in space/time tradeoffs),
or general properties such as synchronization, modifiability, ordering,
sorting, and constraints in general.

This section briefly reviews 17 collection libraries
to identify the provided collection types
and high-level design differences.

\paragraph{C11}

% - C
%   - array
% - GNU libc: hsearch, tsearch

C, one of the most widely used languages is a somewhat interesting corner case.
The C11 standard only includes a single collection-like abstraction: arrays.
In comparison to other languages, C arrays are merely raw memory.
They neither include a length nor any form of safety checks,
and thus represents the minimal possible abstraction that could be provided.
The \citeurl{GNU C Library}{The GNU C Library (glibc)}{GNU Project}{}{https://www.gnu.org/software/libc/}
expands only minimally on arrays
by providing hash table and tree-based abstractions
mainly design for searching and sorted access.

\paragraph{C++17 and boost 1.66}

% - C++
%  - sequences
%   - array, vector, deque, forward\_list (singly linked list), list (double)
% 
%  - associative
%   - set, map
%   - also unordered
% 
%  - adapters
%    - stack, queue

C++17\citep{Cpp17} expands on C
by providing a template-based standard library (STL).
It includes C arrays but also an STL version, which can do bounds checking.
Additionally, it includes vectors, deques, singly and doubly linked lists,
sets and maps in an ordered and unordered variant,
as well as adapters to realize stack or queue semantics.
Generally, the STL remains comparably lean,
but already provides collections with different performance tradeoffs
that enable programmers to chose based on their expected usage scenarios.

% boost C++
%  - expands with specialized containers,
%    mostly specific to C++ language constrains
%    - and different representation tradeoffs
%    - different vector classes (stable, static, small)
%    - flat sets/maps (instead of using trees)
%      - worse at insertion but faster lookup
%    - heap (priority queues)
%    - collections packing objects by type (for performance) PolyCollection
%  -> indicates that here performance is main driver for variability
The \citeurl{boost C++ libraries}{Boost C++ Libraries}{boost.org}{}{http://www.boost.org/}
expand on the STL by adding more specialized containers,
which at least partially address C++-template specific issues.
The variations on the vector class address different performance tradeoffs.
Similarly, the tree-based sets and maps of the STL are complemented
with hash-based implementations.
The overall theme seems to be to address a recurring need for collections
that are optimized for specific use cases.

\paragraph{Go 1.9}

% - Go
%  - arrays, slices, maps
%  - heap, list, ring
%  - no sets

The \citeurl{Go language}{The Go Programming Language}{Go Project}{}{https://golang.org/}
comes with abstractions for arrays, slices, lists, rings, maps, and heaps.
Overall, the library focuses on the basic abstractions needed.
For instance, it does not contain a separate set type,
perhaps because it can be easily modeled based on maps.

\paragraph{Java 8}

% - Java
%   - arrays

In contrast, \citeurl{Java 8}{Java SE 8}{Oracle}{}{https://docs.oracle.com/javase/8/}
has a large collection library.
% array
As basic abstraction, the language includes arrays,
which can be of different primitive or object types.
% map, list, set, deque, stack
Its standard library provides implementations for a wide variety of collections
including lists, maps, sets, queues, deques, priority queue, stacks,
% - iterators
and iteration abstractions.
Many of the collections come in different variations.
% - hash map/set, tree map/set
For maps and sets, there are hash or tree-based implementations.
% - lists: linked, array
Lists are implemented for instance as linked or array lists,
% - skip list, CopyOnWriteArrayList
which is then complemented with skip lists, or copy-on-write lists.
Depending on the collection type,
% - ordered collections
% - navigable collections
% - readonly/unmodifiable collections
% - weak collections
there are also usually additional variations that for instance
provide ordering guarantees, sorting, make them navigable,
enforce read-only access, reference elements only weakly,
or give additional guarantees for concurrent access.
% - concurrent collections
Concurrent access can be synchronized
for instance with a basic synchronization wrapper,
or by using a specific data structure
that might have less synchronization overhead
or allows for more parallelism.

As a result,
the standard library provides a large number of collection implementations.
While some of the offered additional properties are provided by wrappers,
and allow for combination,
many of them are separate implementations tuned for specific use cases.

\paragraph{Guava 24}

% - Guava
\citeurl{Guava}{Guava: Google Core Libraries for Java}{Guava Project}{}{https://github.com/google/guava}
%  - extension, keeps compatibility and set of concepts (for many elements)
%  - iterators
extends the Java collection library with additional utility methods,
while keeping basic compatibility with it.
%  - multiset, multimap, bimap, table (2 nested maps), RangeSet, RangeMap
It also adds new collection types including multi-sets, multi-maps, 
bidirectional maps, tables, as well as range sets and maps.
%  - immutable collections (more optimized over unmodifiable)
Furthermore, it adds immutable versions of the basic collection types.
Here the focus is on representing the collections more efficiently in memory,
and possibly also improving performance for access operations
compared to Java's read-only/unmodifiable collection wrappers.

\paragraph{Eclipse Collections 9.1}

The \citeurl{Eclipse Collections library}{Eclipse Collections}{Eclipse Foundation}{}{https://www.eclipse.org/collections/}
% extension, keeps compatibility and set of concepts (for many elements)
is also an extension to the Java standard library keeping basic compatibility.
% - BiMap, Bag, Multimap
Similarly to Guava, it adds new collections
including bidirectional maps, multi-maps, bags,
and provide additional utilities.
% rich iteration operation, incl. lazy and parallel iteration
This includes rich support for iteration
for instance to iterate lazily or in parallel.
%    - mutable and immutable collections
It also adds immutable collections.
% - specializations for primitive types
Additionally, it provides specialized collection types for primitive types
to avoid boxing overhead of Java's collection types.

\paragraph{C\# and .NET Framework 4.7}

Similar to Java, \citeurl{C\# and the .NET Framework}{.NET API}{Microsoft}{}{https://docs.microsoft.com/en-us/dotnet/api/?view=netframework-4.7.1}
%  - arrays
%  - ArrayList, BitArray, Dictionary (hashtable), queue, stack, HashSet,
%    LinkedList
have arrays, lists, sets, maps, queues, and stacks.
While the framework includes linked and array lists,
it is does not include explicit tree sets or maps for instance.
%  - ordered collections
However, it also includes sorted collections,
which might be implemented as trees though the .NET documentation refrains from
giving any guarantees on the cost of operations
or a specific implementation technique.
%  - read only collections (just wrapper, not truely immutable, just a readonly view)
%  - immutable (persistent/structural sharing)
Similar to Java, they provide read-only, \ie, unmodifiable collections,
which are simply wrappers for normal collections.
Additionally, they also provide truly immutable collections,
which support structural sharing, \ie,
are implemented as persistent data structures.
%  - concurrent collections
%  - synchronzied collection
In order to support thread-safety,
they provide generic synchronization wrappers
as well as special-purpose concurrent collections
with better concurrent behavior.

%  - iterators, query support
One feature that seems to be specific to .NET
is the support for advanced query operations on collections with LINQ,
which are an addition to the traditional iteration operations.

\paragraph{Scala 2.12}

\citeurl{Scala}{Scala Standard Library}{EPFL}{}{http://www.scala-lang.org/api/2.12.4/}'s standard library
comes with collections somewhat similar to Java.
% - maps, sets, sequences
% - arrays
It supports arrays, maps, sets, and sequences as basic abstractions.
% HashMap, HashSet, TreeMap, TreeSet, ArraySeq, DoubleLinkedList
It got hash and tree-based versions for sets and maps
as well as array-based or doubly linked lists
to cover the main implementation strategies.
%  - BitSets, , ListMap, LinkedHashMap/Set, MultiMap, Queue, Range, Stack, Stream, Vector, WeakHashMap
It got special-purpose collections
such as bit sets, list maps, integer maps, linked hash maps or sets, multi-maps,
queues, stacks, vectors, or weak hash maps.
The library is however structured differently.
% - mutable
% - immutable/persistent
The main distinction is between mutable and immutable version
of the collections.
The immutable collections are typically implemented
as persistent data structures with structural sharing.
Both types of collections are polymorphic on the basic non-mutating operations,
which makes their use very flexible. 
Additionally, the library provides concurrent, sorted,
and parallel versions of some of the collections.
The parallel collections focus on parallel execution of bulk operations.

% - iterators
% - concurrent
% - sorted collections
% - parallel
%    - has collection framework with mutable and immutable collections
%      -> the have the same basic structure
%      -> APIs facilitate the same programming style
%      -> since Scala embraces OO and FP, this seems not surprising
%
%    - uniform return type principle \smtodo{was this in \citet{Odersky:2009}?} \url{https://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html}
%     The Architecture of Scala Collections

\paragraph{Haskell}

% - immutable collections
%   - lists basic builtin type
%   - tuples

Haskell contains only immutable lists and tuples as basic builtin types.
Other collections seem to be provided as external packages.
% - concurrent queue (Chan)
This includes for instance channels, which are concurrent queues.
The \emph{containers} library provides
sequences, maps, graphs, sets, trees, and bit queues.
Some of these are provided as lazy or strict variants
to give programmers more fine-grained control.
Similarly, it provides special sets and maps for integers,
presumably for performance reasons.

% - containers library
%   - sequences (different performance than lists)
%   - map, graphs, sets, tree
%   - integer collections (sets, maps)
%   - lazy or strict
%   - BitQueue

\paragraph{Racket 6.12}

% - Pairs and Lists (immutable versions prefered)
\citeurl{Racket}{The Racket Reference}{Racket Project}{}{https://docs.racket-lang.org/reference/} provides basic pairs and lists in the Scheme tradition.
% - Vectors
% - Boxes (1-elem vector)
% - Hash Tables
% - Sets
In addition, it provides, vectors, boxes, hash tables, and sets.
% - immutable versions
Most collections are available as immutable and mutable variants.
% - channels (synchronized)
To support concurrency, it provides channels,
which are in their asynchronous variant synchronized queues. 

\paragraph{Pharo 6}
Pharo 6's collection library is based on the classic collection library
of Smalltalk\citep{Smalltalk80,Cook:1992:ISS}.
% HashedCollection, Array, bags, stack, set, bag, Matrix, DoubleLinkedList
It includes arrays, maps, sets, bags, stacks, matrixes, and doubly linked lists.
% - OrderedCollection, OrderedDictionary
% - SortedCollection
% - IdentityDictionary, IdentityBag, IdentitySet
Some collections are available in variants that support ordering, sorting,
or are based on identity.
% primitive arrays
It also offers arrays of primitive types that store values raw in memory.
% SmallDictionary, SmallIdentityDictionary
Small maps can use classes that are specifically optimized for this purpose.
% - concurrent collections (LIFOQueue, WaitfreeQueue, AtomicSharedQueue)
% - weak collections
Similar to other languages,
it includes weak collections, as well as a number of queues for concurrent use.

\paragraph{Ruby 2.5}

With respect to the number of collection types offered,
Ruby's library is comparably small.
% - Array, Hash,
Its main collection types are arrays and maps.
% - Queue, SizedQueue, WeakMap, Range
Instead of providing support for ordered or linked maps,
insertion order is maintained by Ruby's \code{Hash} map in all cases.
It also provides variable size and bounded queues, a range abstraction,
and weak maps.
% - freeze, sort
Immutability of collections is supported by Ruby's mechanism to freeze objects,
\ie, to make them immutable.
Sorting is not provided as part of separate collection types either.
Instead arrays support sorting operations.

\paragraph{JavaScript, ECMAScript 2016}

% Array, Object
JavaScript's collection library used to be minimalistic and offered merely
arrays and objects, which could be used as maps.
% map, set
Since maps that accept only strings as keys can be limiting,
newer versions of the ECMAScript standard introduced maps, sets,
% - WeakMap/WeakSet
and their weak counter parts.
% - primitive arrays (TypedArray), views for byte-based ArrayBuffers
They also introduced typed arrays, \ie,
views on raw memory that allow representing certain number types
directly in memory.

\paragraph{Python 3.6}

% - deque, set, list, tuple, range, dict,
Python offers lists, tuples, ranges, sets, maps, and deques
as basic collections.
Since Python 3.6, \code{dict} maintains insertion order and
% -  OrderedDict (going to be default)
makes the separate \code{OrderedDict} redundant.
To provide the ability to create a single view on multiple maps,
it offers \code{ChainMap}.
% frozenset
To enable sets of sets, it offers also a \code{frozenset},
which has the necessary support for obtaining a hash value.
% - queue (synchronized)
Similar to Racket,
it provides a synchronized queue abstraction
to facilitate communication between multiple threads.
%  - typed primitive arrays
To represent number types efficiently, it also supports typed arrays.
% bytes, bytearray (imm vs mutable)
A special case is here the \code{bytes} type,
which is an immutable byte sequence that is used for instance for byte literals.

\paragraph{Dart 1.24}

% - lists, LinkedList, set, map, DoubleLinkedQueue, ListQueue, Queue
Dart's standard library includes lists, linked lists, sets, maps, list queues,
or doubly linked queues.
% - HashSet, LinkedHashSet, SplayTreeSet
% - HashMap, LinkedHashMap, SplayTreeMap
Sets and maps are available either using hash tables,
linked hash tables, or splay trees.
Similar to other dynamic languages,
% primitive type lists
Dart also offers lists of primitive types
for efficient representation in memory.

% Potentially TODO:
% - Eiffel, Pascal, Ada, ... other old-school stuff
% - Oz, Prolog, Erlang, ...
% - ML, Ocam, Ocaml, ...
% - other unconventional languages

\section{Design Dimensions for Collection Libraries}

Based on the observations of \cref{sec:col-wild},
this section distills the design dimensions for collection libraries. 

\subsection{Types of Collections}

The first dimension is the types of collections to be included in the library.
Here, we abstract as much as possible
from general properties of collections (cf. \cref{sec:col-properties})
and other implementation or representation choices
(cf. \cref{sec:impl-choices}),
which we try to consider as orthogonal concerns
even so it is not always obviously beneficial.

% - array
% - list/vector, tuples, pairs, boxes
% - bags/multisets
Consequently,
the first category of collection types is \emph{bags or sequences}.
Considering ordering, mutability, sizing, and representation
as orthogonal concerns,
this category includes arrays, lists, vectors, tuples, pairs, and boxes.
Generally, these collections provide the ability to store elements
that are possibly repeating
and operate on them perhaps by direct access or via iteration of some sort.

% - set
The second category is \emph{sets}.
Thus, collections that do not maintain repeated elements
and only store a single occurrence based on some equivalence criterion.

% - map
% - multi-map
% - bidirectional map
The third category is \emph{maps}.
These collections store key/value pairs of some sort.
Languages such as Racket allow polymorphism between index collections and maps.
This could lead to an argument that ordered maps are sufficient to represent
any kind of sequence,
from which we refrain here even though Lua 5.0 only offers tables\citep{The_implementation_of_lua}.\sm{should I break this out and put this into the survey section?}

% - stack
% - queue
% - deque
% - priority queues
%   - heap
% - ring
The forth category is \emph{stacks and queues}.\sm{better name?}
These collections store elements
and restrict the access in a way
that facilitates the efficient implementation of certain use cases.
We include here deques, priority queues or heaps, and rings.

% - matrix
% - table 
The fifth category is \emph{composed collections}.
These are collections that could be built by combining multiple collections.
We include here for instance matrixes, which are two-dimensional arrays,
and tables, which are two-dimensional maps.
Again, these two could be considered of the same class
if indexing with integers is considered a associative access.

% - range/slice
% - range map/set
The six category is \emph{ranged collections}.
These seem to be rare in form of range maps or sets.
However, we include here the ranges or slices as well,
which are available in some languages
and correspond to a reified potential iteration.

\subsection{Language Style}

\begin{note}
  - language style
    - object-oriented, procedural, functional, ...
    
    - support for primitive types (Java generics vs C\# or C++ templates, dynamic language)

    primitive type lists
     - templates
     - explicit
    primitive maps/sets, ...
      - primitive as keys or values
     - bit sets
     
- target language
 - abstractions present in the underlying language influence design
   -> typed languages
     -> expressiveness of type system might restrict or guide the shape
        of the library
     -> can have influence on aspects such as code duplication etc
     -> Scala experience paper as example
     -> template in C++ different in expressive power and constraints
     -> Haskell and other languages compared \citep{Garcia:2007}
       -> sometimes language might need to evolve to enable the desired design \citep{Chakravarty:2005:ATC} \citep{Black:2003:ATS} (see below, need to structure this correspondingly)
       
  -> code reuse and structure
    -> available language mechanism shape the library
    -> or lead to suboptimal designs
     -> Smalltalk example \citep{Cook:1992:ISS}
       -> if you only got single inheritance, only mechanism of reuse
          that does not need composition (which might introduce other issues,
          for instance performance overhead in interpreted languages)
       -> subclassing not always ideal
       -> some things are just not subclasses
         -> deleting methods
         -> providing other functionality via same name
         -> structuring request much care
\end{note}

\subsection{Properties}
\label{sec:col-properties}

\begin{note}
  - mutability (mutable, immutable, read-only wrappers)
   - absolute vs opt-in  
  - persistence (persistent data structures, just an implementation technique for immutable collections? or does it have a design impact? probably, because of performance aspects)

  - fixed size/variable
  
  - concurrent (various different use cases for same collections)
  - parallel (for bulk operations, can also be realized via streams)
  - synchronized (just thread-safe wrappers)
  - ordered
  - sorted (absolute, opt-in)
  - weak
  - lazy vs strict
  - identity-specific collections
  - copy on write
  


\end{note}

\subsection{Operation Design}

\begin{note}
  - basic operations
  
  - polymorphism 
    - compatibility of collections
      - maps as lists (iteration), lists as maps (int->T maps)
      - immutable/mutable...
      - use of wrappers?
  
  
  - bulk operation
    - order guarantees (everything modeled as lists)
    - processing (sequential, parallel, lazy)
    - slices
    - internal/external iteration
      - streams
      - queries (linq)
      - navigation (navigable Java)
      
\end{note}

\subsection{Algorithms, Data Structures, and Implementation Choices}
\label{sec:impl-choices}

\begin{note}
  - wrappers for properties
  - trees
  - tries, splay trees
  - skip lists
  - singly/doubly linked lists
 - hash
  - specializations for small dicts
  - specialization for stable, static, small vectors/lists
\end{note}

\section{Collection Usage}

As seen in the previous section,
collection libraries differ widely
in the number of collection types they provide
and the properties these collections can offer.
Especially Java provides a multitude of different collection types and still,
the wider community felt the need to provide and maintain libraries
for additional collections.
One important question to guide the design could therefore be,
which collection types are widely used and are likely going to be needed
for exploratory programming tasks.

To answer the question of which collection types are widely used,
\citet{Costa:2017:ESU} studied a GitHub corpus of Java projects\citep{6624029}.
They found that most instantiation sites for collections
create \code{ArrayList} objects.
From all sites analyzed, 47\% used the standard Java \code{ArrayList}.
Overall, about 56\% used some kind of list.
Maps where used by about 28\%,
where the great majority uses Java's \code{HashMap},
which results in a total of about 23\% of all allocations.
About 15\% all instantiation sites were for some set type,
Again, the large majority was for Java's \code{HashSet}
with about 10\% of all allocations.

The only other study of the usage of collections we are aware of
was included in work by \citet[sec. 9.2]{Bergel:2018}.
They observed that \code{OrderedCollection} (similar to \code{ArrayList})
and \code{Dictionary} (a map) are the most frequently used collections
in some larger Pharo Smalltalk projects.
While the study is less comprehensive than the Java one,
it confirms the general trend.
Interestingly, it also considers arrays
and fond that they are used slightly more often than \code{Dictionary}.


\section{Techniques for Efficient Implementations}


\begin{note}
  TODO: add M. Steindorfer as reference for complex immutable/specialized data structures \citep{Steindorfer:2015:OHM}
  
  
  what is required in terms of efficiency?
  compilation-time feedback - needs to be fast to compile
  run-time performance - needs to be fast to execute

  \citep{Rein:2016:LLP} should look a little more into this one for terminology
  
Discussion Points:
 
Practical Implementation Concerns
 How to realize all this with same efficiency as when using special purpose
 collections?
 - probably not getting there 100\%, but 90\% or even 80\% are sufficient
   when it improves developer productivity (which still has to be proven of course)
  
 - to get to the 80-90\% mark
  -> strategies (seq, par)
   - Storage strategies for collections in dynamically typed languages \citep{Bolz:2013:SSC}
   -> concurrency strategy paper
  -> JIT Data Structures
     -> the other paper about collections I saw (something from a german university)

  -> CollectionSwitch: A Framework for Efficient and Dynamic Collection Selection
DOI 10.1145/3168825
CGO 2018 (to appear)
  -> cameleon, ... (JIT DS references)
% \url{https://www.researchgate.net/publication/322438185_CollectionSwitch_A_Framework_for_Efficient_and_Dynamic_Collection_Selection

- Tobias Pape's paper, for functional data structures


- compiler for static languages can do certain optimizations ahead of time:
  - compiler-level specialization as with miniboxing \citep{Ureche:2013:MIS}
  - C++ templates (expanding ones), eager specialization

How to design so that specialized collections remain possible?
And are easily adopted?
 -> ensure subset of collection APIs are polymorphic
   -> ideally, one just changes the constructor, or adds a conversion
   -> idea would be that this gives the last 10-20\% of performance when needed
   -> leave door open for improving performance by restricting flexibility
\end{note}


\section{A Collection Design for Exploratory Programming}

\begin{note}
  - Generalization vs. Specialization  
  - small set of generalized collection types 
  - or large set of specialized types
  
  - is small and versatile bad design because it violates the `one thing does   one thing good premise'
    - are those classes blobs? \citep{brown1998antipatterns}
    - do they do too much? is this an issue?
     -> yes, it's an issue, the code is not clear about what kind of 
        interactions one wants to allow on the collection
     -> complexity of implementation is a real issue (concurrency issues,
        strategies, JIT DS...)
     -> this means, it can be a burden for maintaining large systems
     -> it is a burden for VM maintenance
     -> however, The Blob anti-pattern combines complex state and behavior
        such collection design is not a direct instance of it, because
        the contained data is usually still used for a single purpose and
        it is merely that the collections themselves offer too much
        functionality

    - benefits of specialized classes:
      - chose specific implementation/algorithm/data structure
      - some people argue that programs are better understood if these things are explicit: \citep{PeytonJones:1996:BTC}
        -> """The type of the object does not specify its invariant (\eg in a set there are no duplicates) and its expected operations (\eg lookup in a infinite map). The lack of these invariants makes the program harder to understand, harder to prove properties about, and harder to maintain."""
        -> generic data structures (lists in case of Haskell) might not be optimal
         -> PJ already talks about 2.3 Adaptive representations
         A probabilistic approach to the problem of automatic selection of data representations \citep{Chuang:1996:PAP}
          -> markov processes

      - example
        -> set/map: implemented as tree or hash table?
        -> linked list or array list, or linked segments?
        -> can't make a right choice without knowing exactly what
           run time load is going to be

    - drawback of too specialized classes:
      - can become inflexible
        -> need conversion or adapters to perform certain operations
        -> large class hierarchies, hard to chose one, might not even be
           clear what options are available, or appropriate for problem
  
\end{note}



\section{Related Work}
\sm{not sure we need this section}

\citet{Odersky:2009} describe their experience
redesigning the collection library in Scala.
Their focus is mostly on how they achieved an implementation and design
that is more principled, structured, and avoids code duplication
to avoid bit rot during future maintenance.
The library itself falls into the category of large and specialized (cf. \cref{sec:scala-col}). 

\citet{Matthes:2000:BT} investigate the question of how to design \emph{bulk types}, i.e., collection libraries, on the intersection to database systems and database programming languages.
They discuss the benefits and drawbacks of builtin or library-based designs and favor library-based designs for their extensibility.
\sm{discussion in paper context: assume we have good knowledge from the various languages and libraries what is necessary, assume that extensibility is not a problem either, because the languages could be dynamic and therefore lent itself naturally to simply changing the collection implementation if required.
Though, there might be limitations to what can be changed without interfering with optimizations such as strategies\todoref{}.}


Live Data Structure Programming \citep{Oka:2017:LDS}
- visualization
- generic data structures

\section{Conclusion}

C has the most minimal collection library, 


While I have convinced myself
that I do prefer the programming style offered
by a small and versatile collections library,
I cannot shake the feeling
that this is a post hoc justification
for the complexity we add to VMs.


%% ATTIC, Notes on Things Considered, but not included
%% ===================================================

%% Streams
%%
%% finite, or infinite sequence of values
%% aren't collections, just one way to express iteration/transformation

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
