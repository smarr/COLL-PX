%% White space:
%% sentence parts on separate lines

% TODO: add review
\documentclass[sigconf, 10pt]{acmart}
%\documentclass[sigconf, 10pt, review]{acmart}
% \documentclass[sigconf, 10pt, authordraft]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\def\Title{Small and Versatile vs. Large and Specialized}
% \def\ShortTitle{}
\def\SubTitle{How to design a collection library for exploratory programming?}
\def\PdfTitle{\Title: \SubTitle}
\def\PdfSubject{TODO}
\def\PdfAuthors{{Stefan Marr, Benoit Daloze}}
\def\PdfKeywords{TODO}

\def\SOMns{SOM{\sc ns}\xspace}

\include{scripts/init}


\collabAuthor{bd}{green!60!black}{Benoit}
\collabAuthor{sm}{red}{Stefan}

\usepackage{booktabs} % For formal tables

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\acmDOI{10.475/123_4} % TODO
\acmISBN{123-4567-24-567/08/06} % TODO

%Conference
\acmConference[PX/18]{Programming Experience Workshop}{April 2018}{Nice, France}
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{15.00}
\acmSubmissionID{123-A12-B3}

\begin{document}
\title{\Title}
% \titlenote{Produces the permission block, and
%   copyright information}
\subtitle{\SubTitle}
% \subtitlenote{The full version of the author's guide is available as
%   \texttt{acmart.pdf} document}

\author{Stefan Marr}
\orcid{0000-0001-9059-5180}
\affiliation{%
    \department{School of Computing}
    \institution{University of Kent}
    \city{Canterbury}
    \postcode{CT2 7NZ}
    \country{United Kingdom}
}
\email{s.marr@kent.ac.uk}

\author{Benoit Daloze}
\affiliation{%
    \department{Institute for System Software}
    \institution{Johannes Kepler University Linz}
    \streetaddress{Altenbergerstra√üe, 69}
    \city{Linz}
    \postcode{4040}
    \country{Austria}
}
\email{benoit.daloze@jku.at}


% The default list of authors is too long for headers.
% \renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}


\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
% TODO
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

% TODO
\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% TODO
\keywords{Collection Libraries, Design, Implementation, Exploratory Programming}

\maketitle


\section{Collections for Exploratory Programming}

% Context: What is the broad context of the work? What is the importance of the general research area?
% - collection libraries
%   essential part of any general purpose language
%   - C doesn't have one?

One of the basic concepts of programming languages are collections or containers, i.e.,
data structures that abstract over the number of data items
and allow operations over the contained items as a whole or individually.
As such, they are a fundamental aspect of general purpose languages.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?

The design of collection libraries varies greatly between languages,
and sometimes there are even multiple libraries
to facilitate different programming styles, application scenarios, or performance requirements.
They can range from having only arrays,
as the exclusive basic abstraction as in C,
to systems such as Java,
where the standard library includes dozens of collection abstractions.
% - library design has major influence on
%   - language style/idioms
%   - programmer productivity (assumed)
%   - feeling of the language
% - as far as we are aware no systematic study
To the best of our knowledge,
there is not systemic study on how the design of a collection library
influences programmer productivity
or a language's suitability for exploratory programming.

% Approach: What was done that unveiled new knowledge?
% - explore design space
%   - which aspects need to be considered
%   - which design dimensions are there
The goal of this study is to identify the aspects
that need to be considered for the design of collection libraries
for exploratory and live programming.
%
%
% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
%- reason about design space for a language designed for exploration
% - high flexibility
% - low friction
%   - avoid making unnecessary decisions,
%   - performance not important
%   - problem first needs to be understood
% - interactive program development
% -> live programming
Thus, we reason about the design space for collections
and how different design choices may influence the programming experience.
We focus specifically on how different design choices relate to the main
programming task\sm{avoid making unnecessary decisions}, performance, and the liveness of the programming experience\sm{feedback potential}.

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
%- argue for feasibility based on existing techniques
In order to get an overview of the design space,
we discuss the high-level design of collection libraries for
\smtodo{review}, C, C++, Go, Java, C\#, Scala, Haskell, Racket, Smalltalk, Ruby, JavaScript, Python, and Dart.
From this overview, we extract the concrete design dimensions
and present arguments for and against design choices
in the context of exploratory programming.
Finally, we review implementation techniques
to judge whether design choices can be practical
in terms of achieving the same performance as alternative choices.

Therefore, this paper\sm{somewhat a contribution statement, but also redundant with the above. Revisit before submission.}

\begin{itemize}
  \item describes the design space for collection libraries
  \item discusses design choices and their suitability for exploratory programming
  \item reviews implementation techniques to ensure practical performance
\end{itemize}

% Importance: Why does this work matter?
% - collections are complex but essential parts of our languages
%   - better understanding will enable more principled design
We hope this analysis provides an insight
into the complex design space of collection libraries
and their relation to the programming experience itself.
Our immediate goal was to better understand the tension between design choices
for the design of a collection library for \SOMns, a Newspeak implementation\citep{Bracha:10:NS,OptCELWithTruffle}.
Newspeak follows in many ways previous Smalltalk systems
and as such has a large and specialized collection library.
However, based on the arguments presented here,
we believe that a small and versatile library would be a more suitable design
for a language as dynamic and \ugh{aimed at exploratory programming} as Newspeak.\sm{not sure about this bit, need to think about it}


\section{Live and Exploratory Programming}

Before diving into the details of designing collection libraries,
we discuss the terms live and exploratory programming
to clarify our assumptions and the context of this analysis.

% - need a brief discussion of what our assumptions are
% - what are the ``requirements''?
% - four levels: \citep{Tanimoto:1990:Viva,Tanimoto:2013:PEL}
%   level 3:
%    - changes update programs
%      -> system might attempt reexecution, possibly only relevant parts
%   level 4:
%    - continuous feedback in time-varying results based on current program

For the term \emph{live programming}, we will rely on \citeauthor{Tanimoto:1990:Viva}'s notion.
Specifically, our aim is to support programming that is supported
by immediate updates and feedback from the programming environment.
This might be either triggered by edits or presented as continuous event streams,
which corresponds to liveness of level 3 or 4\citep{Tanimoto:1990:Viva}.
While generally desirable, we forgo considering more advanced liveness levels
that include predictive features, \ie, level 5 and 6\citep{Tanimoto:2013:PEL}.

%  - feedback on valid programs
%  - feedback on execution
Based on these liveness level and on the work of others\citep{McDirmid:2007:LUL,Burckhardt:2013:ACF,Rein:2016:LLP},
we expect programming environments and languages
to improve the programming experience by providing immediate feedback on
the validity of programs and code execution.
This feedback should be meant to reduce the friction
that is inherent in the communication between humans and machines,
which is constrained by artificial languages and machines
that still neither perceive the context of a conversation nor learn from interaction.
To work around these limitations in our communication,
we expect machines to support the communication with feedback,
limited forms of understanding,
and a basic robustness to invalid communication.

%% Feedback
% - want feedback on valid operations in terms of
Feedback should be provided in form of
%   - code completion, documentation
code completion, contextual documentation,
%   - error highlighting (unsupported methods)
syntax errors, possibly invalid method calls or operations \bd{is that exceptions?},
and style errors or undesirable patterns.
% - edit/feedback latency
%   - feedback should be fast, overall execution fast enough
% - state snapshots, reexecution, redisplay
% - should not prevent state snapshots (seems orthogonal)
% - possibility of continuous feedback
%   (seems to be orthogonal, but should not be prevented)
The analyses that enable such feedback need to be implementable
in an efficient manner to give the illusion of instantaneous feedback.
%
%% Understanding
% - implicit over explicit, for types
%   - types inferred or dynamic
With limited forms of understanding,
we refer essentially to analyses
that allow programmers to be more implicit than explicit in their programming.
One aspect of this is typing.
Traditionally, languages that use type inference
or tool-based feedback seem to facilitate exploratory programming better
than languages that require us to make such aspect explicit.
%   
%% Robustness
% - error recovery, robustness, non-interference of irrelevant parts
% - program errors in unrelated/unexecuted parts need to be ignored
The overall system should also be robust with respect to programming errors.
Especially errors in unrelated program parts,
or parts that are not actually executed
should not inhibit our ability to interact with the system,
explore and extend it.

%% 
Generally, when exploring a problem and experimenting with solutions,
we want to focus on the problem domain and prioritize the core aspects
while deferring for instance overall application performance,
handling of exceptional cases,
or the completeness of a solution to a later point.
Thus, the programming environment should not force us to make decisions,
which we cannot yet make because of our incomplete understanding of the problem
or inaccurate predictions of how an algorithm is used in production scenarios.
Types or structural elements often help exploring
the problem and organizing thoughts,
but should not prevent or hinder us from exploring it.

% - focus decision making on problem and domain
%   - application performance secondary concern,
%    as long as feedback is not impaired 
% - types or at least structure might still be helpful to organize ones thoughts
Since collections are frequently used for bulk operations
that might end up being relevant for acceptable performance,
run-time performance is a relevant aspect and needs to be considered.
While it is not of highest priority for application performance,
it should also not impede live feedback.

\section{Collection Design in the Wild}
\label{sec:col-wild}

% - having a brief look around, informally, just getting a flavor
%  - what collections do they contain
%  - how large (num classes/concepts) are libraries
%  - any particularly interesting things?

Collection library design seems to be as diverse as languages are different.
\del{There is a multitude of design dimensions that can be varied.}
\ins{There are many design dimensions to consider.}
Some of them are influenced by the underlying language,
its basic abstractions,
as well as what is considered desirable programming style, \ie, idiomatic code.
Other dimensions include the set of offered collection types,
implementation strategies (usually differing in space/time tradeoffs),
or general properties such as synchronization, modifiability, ordering,
sorting, and constraints in general.

This section briefly reviews 17 collection libraries
to identify the provided collection types
and high-level design differences.

\paragraph{C11}

% - C
%   - array
% - GNU libc: hsearch, tsearch

C, one of the most widely used languages, is an interesting case as the C11 standard only includes a single collection-like abstraction: arrays.
In comparison to other languages, C arrays are merely raw memory.
They neither include a length nor any form of safety checks,
and thus represents the minimal possible abstraction that could be provided.
The \citeurl{GNU C Library}{The GNU C Library (glibc)}{GNU Project}{}{https://www.gnu.org/software/libc/}
expands only minimally on arrays
by providing hash table and tree-based abstractions \bd{more precise link? function names?}
mainly designed for searching and sorted access.

\paragraph{C++17 and Boost 1.66}

% - C++
%  - sequences
%   - array, vector, deque, forward\_list (singly linked list), list (double)
% 
%  - associative
%   - set, map
%   - also unordered
% 
%  - adapters
%    - stack, queue

C++17\citep{Cpp17} expands on C
by providing a template-based standard library (STL).
% BD: link to the documentation: http://en.cppreference.com/w/cpp/container ?
It includes C arrays but also an STL version, which can do bounds checking.
Additionally, it includes vectors, deques, singly and doubly linked lists,
sets and maps in an ordered and unordered variant,
as well as adapters to realize stack or queue semantics.
Generally, the STL remains comparably lean,
but already provides collections with different performance tradeoffs
that enable programmers to chose based on their expected usage scenarios.

% Boost C++
%  - expands with specialized containers,
%    mostly specific to C++ language constrains
%    - and different representation tradeoffs
%    - different vector classes (stable, static, small)
%    - flat sets/maps (instead of using trees)
%      - worse at insertion but faster lookup
%    - heap (priority queues)
%    - collections packing objects by type (for performance) PolyCollection
%  -> indicates that here performance is main driver for variability
The \citeurl{Boost C++ libraries}{Boost C++ Libraries}{boost.org}{}{http://www.boost.org/}
expand on the STL by adding more specialized containers,
which at least partially address C++-template specific issues.
The variations on the vector class address different performance tradeoffs.
Similarly, the tree-based sets and maps of the STL are complemented
with hash-based implementations. \bd{std::unordered\_map is a HashMap!}
The overall theme seems to be to address a recurring need for collections
that are optimized for specific use cases.

\paragraph{Go 1.9}

% - Go
%  - arrays, slices, maps (http://www.golangbootcamp.com/book/collection_types)
%  - heap, list, ring (from where?)
%  - no sets

The \citeurl{Go language}{The Go Programming Language}{Go Project}{}{https://golang.org/}
comes with abstractions for arrays, slices \bd{slices are just a view of arrays it seems, can we settle on a common terminology for this?}, lists, rings, maps, and heaps.
Overall, the library focuses on the basic abstractions needed.
For instance, it does not contain a separate set type,
perhaps because it can be easily modeled based on maps.

\paragraph{Java 8}

% - Java
%   - arrays

In contrast, \citeurl{Java 8}{Java SE 8}{Oracle}{}{https://docs.oracle.com/javase/8/} \bd{9?}
has a large collection library.
% array
As basic abstraction, the language includes arrays,
which can be of different primitive or object types.
% map, list, set, deque, stack
Its standard library provides implementations for a wide variety of collections
including lists, maps, sets, queues, deques, priority queue, stacks,
% - iterators
and iteration abstractions. \bd{Are iterators relevant? It's just a way to access containers, no?}
Many of the collections come in different variations.
% - hash map/set, tree map/set
For maps and sets, there are hash or tree-based implementations.
% - lists: linked, array
Lists are implemented for instance as linked or array lists,
% - skip list, CopyOnWriteArrayList
which is then complemented with skip lists, or copy-on-write lists.
Depending on the collection type,
% - ordered collections
% - navigable collections
% - readonly/unmodifiable collections
% - weak collections
there are also usually additional variations that for instance
provide ordering guarantees, sorting, make them navigable,
enforce read-only access, reference elements only weakly,
or give additional guarantees for concurrent access.
% - concurrent collections
Concurrent access can be synchronized
for instance with a basic synchronization wrapper,
or by using a specific data structure
that might have less synchronization overhead
or allows for more parallelism.

As a result,
the standard library provides a large number of collection implementations.
While some of the offered additional properties are provided by wrappers,
and allow for combination,
many of them are separate implementations tuned for specific use cases.

\paragraph{Guava 24}

% - Guava
\citeurl{Guava}{Guava: Google Core Libraries for Java}{Guava Project}{}{https://github.com/google/guava}
%  - extension, keeps compatibility and set of concepts (for many elements)
%  - iterators
extends the Java collection library with additional utility methods,
while keeping basic compatibility with it.
%  - multiset, multimap, bimap, table (2 nested maps), RangeSet, RangeMap
It also adds new collection types including multi-sets, multi-maps, 
bidirectional maps, tables, as well as range sets and maps \bd{What the heck is a RangeSet? Maybe link for it?}.
%  - immutable collections (more optimized over unmodifiable)
Furthermore, it adds immutable versions of the basic collection types.
Here the focus is on representing the collections more efficiently in memory,
and possibly also improving performance for access operations
compared to Java's read-only/unmodifiable collection wrappers.

\paragraph{Eclipse Collections 9.1}

The \citeurl{Eclipse Collections library}{Eclipse Collections}{Eclipse Foundation}{}{https://www.eclipse.org/collections/}
% extension, keeps compatibility and set of concepts (for many elements)
is also an extension to the Java standard library keeping basic compatibility.
% - BiMap, Bag, Multimap
Similarly to Guava, it adds new collections
including bidirectional maps, multi-maps, bags,
and provide additional utilities.
% rich iteration operation, incl. lazy and parallel iteration
This includes rich support for iteration
for instance to iterate lazily or in parallel.
%    - mutable and immutable collections
It also adds immutable collections.
% - specializations for primitive types
Additionally, it provides specialized collection types for primitive types
to avoid boxing overhead of Java's collection types.\bd{Which multiplies the number of collections and is tons of duplicated code!}
\bd{Need to clearly nest those 2 under Java}

\paragraph{C\# and .NET Framework 4.7}

Similar to Java, \citeurl{C\# and the .NET Framework}{.NET API}{Microsoft}{}{https://docs.microsoft.com/en-us/dotnet/api/?view=netframework-4.7.1}
%  - arrays
%  - ArrayList, BitArray, Dictionary (hashtable), queue, stack, HashSet,
%    LinkedList
have arrays, lists, sets, maps, queues, and stacks.
While the framework includes linked and array lists,
it does not include explicit tree sets or maps for instance.
%  - ordered collections
However, it also includes sorted collections,
which might be implemented as trees though the .NET\bd{hard to parse, can change to C\#?} documentation refrains from
giving any guarantees on the cost of operations
or a specific implementation technique.
%  - read only collections (just wrapper, not truely immutable, just a readonly view)
%  - immutable (persistent/structural sharing)
Similar to Java, they provide read-only, \ie, unmodifiable collections,
which are simply wrappers for normal collections.
Additionally, they also provide truly immutable collections,
which support structural sharing, \ie,
are implemented as persistent data structures.\bd{Would turn it around to start with the well know term persistent and define it after}
%  - concurrent collections
%  - synchronzied collection
In order to support thread-safety,
they provide generic synchronization wrappers
as well as special-purpose concurrent collections
with better concurrent behavior.

%  - iterators, query support
One feature that seems to be specific to .NET
is the support for advanced query operations on collections with LINQ\bd{add link?},
which are an addition to the traditional iteration operations.

\paragraph{Scala 2.12}

\citeurl{Scala}{Scala Standard Library}{EPFL}{}{http://www.scala-lang.org/api/2.12.4/}'s standard library
comes with collections somewhat similar to Java.\bd{I know some who would disagree...}
% - maps, sets, sequences
% - arrays
It supports arrays, maps, sets, and sequences as basic abstractions.
% HashMap, HashSet, TreeMap, TreeSet, ArraySeq, DoubleLinkedList
It got hash and tree-based versions for sets and maps
as well as array-based or doubly linked lists
to cover the main implementation strategies.
%  - BitSets, , ListMap, LinkedHashMap/Set, MultiMap, Queue, Range, Stack, Stream, Vector, WeakHashMap
It got special-purpose collections
such as bit sets, list maps, integer maps, linked hash maps or sets, multi-maps,
queues, stacks, vectors, or weak hash maps.
The library is however structured differently.
% - mutable
% - immutable/persistent
The main distinction is between mutable and immutable version
of the collections.
The immutable collections are typically implemented
as persistent data structures with structural sharing.
Both types of collections are polymorphic on the basic non-mutating operations,
which makes their use very flexible.\bd{And impossible to understand without looking up the import :(. Maybe we can communicate that somehow?}
Additionally, the library provides concurrent, sorted,
and parallel versions of some of the collections.
The parallel collections focus on parallel execution of bulk operations.

% - iterators
% - concurrent
% - sorted collections
% - parallel
%    - has collection framework with mutable and immutable collections
%      -> the have the same basic structure
%      -> APIs facilitate the same programming style
%      -> since Scala embraces OO and FP, this seems not surprising
%
%    - uniform return type principle \smtodo{was this in \citet{Odersky:2009}?} \url{https://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html}
%     The Architecture of Scala Collections

\paragraph{Haskell}

% - immutable collections
%   - lists basic builtin type
%   - tuples

Haskell contains only immutable lists and tuples as basic builtin types.
Other collections seem to be provided as external packages \bd{stdlib or really packages to install separately?}.
% - concurrent queue (Chan)
This includes for instance channels, which are concurrent queues.
The \emph{containers} library provides
sequences, maps, graphs, sets, trees, and bit queues.
Some of these are provided as lazy or strict variants
to give programmers more fine-grained control.
Similarly, it provides special sets and maps for integers,
presumably for performance reasons.

% - containers library
%   - sequences (different performance than lists)
%   - map, graphs, sets, tree
%   - integer collections (sets, maps)
%   - lazy or strict
%   - BitQueue

\paragraph{Racket 6.12}

% - Pairs and Lists (immutable versions prefered)
\citeurl{Racket}{The Racket Reference}{Racket Project}{}{https://docs.racket-lang.org/reference/} provides basic pairs and lists in the Scheme tradition.
% - Vectors
% - Boxes (1-elem vector)
% - Hash Tables
% - Sets
In addition, it provides, vectors, boxes\bd{uh?}, hash tables, and sets.
% - immutable versions
Most collections are available as immutable and mutable variants\bd{differentiated by name or package?}.
% - channels (synchronized)
To support concurrency, it provides channels,
which are in their asynchronous variant synchronized queues.\bd{confusing}

\paragraph{Pharo 6}
Pharo 6's collection library is based on the classic collection library
of Smalltalk\citep{Smalltalk80,Cook:1992:ISS}.
% HashedCollection, Array, bags, stack, set, bag, Matrix, DoubleLinkedList
It includes arrays, maps, sets, bags, stacks, matrices, and doubly linked lists.
% - OrderedCollection, OrderedDictionary
% - SortedCollection
% - IdentityDictionary, IdentityBag, IdentitySet
Some collections are available in variants that support ordering, sorting,
or are based on identity.
% primitive arrays
It also offers arrays of primitive types that store raw values in memory.
% SmallDictionary, SmallIdentityDictionary
Small maps can use classes that are specifically optimized for this purpose.
% - concurrent collections (LIFOQueue, WaitfreeQueue, AtomicSharedQueue)
% - weak collections
Similar to other languages,
it includes weak collections, as well as a number of queues for concurrent use.

\paragraph{Ruby 2.5}

With respect to the number of collection types offered,
Ruby's library is comparably small.
% - Array, Hash,
Its main collection types are arrays and maps.
\ins{Instead of multiple collection types for lists, deques, stacks, etc,
Ruby supports operations for these in \code{Array}.}
% - Queue, SizedQueue, WeakMap, Range
Instead of providing support for ordered or linked maps,
insertion order is maintained by Ruby's \code{Hash} map in all cases.
\bd{Same for compare-by-identity, it's a flag within Hash, but too much details perhaps, although nice anecdote?}
It also provides variable size and bounded queues for multithreading, a range abstraction\bd{Not a collection? Go and others also supports ranges, but seems irrelevant},
and weak maps.
% - freeze, sort
Immutability of collections is supported by Ruby's mechanism to freeze objects,
\ie, to make them immutable.
Sorting is not provided as part of separate collection types either.
Instead arrays support sorting operations.\bd{Note: Hash too, it's Enumerable\#sort, which always return an Array}
\bd{Should mention Enumerable contains 56 general iteration+transformation methods for all collections based on \#each? Or Array has 101 methods so iterating loops/iterating by index is rarely needed in Ruby and most used cases are built-in?}

\paragraph{JavaScript, ECMAScript 2016}

% Array, Object
JavaScript's collection library used to be minimalistic and offered merely
arrays and objects, which could be used as maps.
% map, set
Since maps that accept only strings as keys can be limiting,
newer versions of the ECMAScript standard introduced maps, sets,
% - WeakMap/WeakSet
and their weak counter parts.
% - primitive arrays (TypedArray), views for byte-based ArrayBuffers
They also introduced typed arrays, \ie,
views on raw memory that allow representing certain number types
directly in memory.

\paragraph{Python 3.6}

% https://docs.python.org/3.6/library/collections.html

% - deque, set, list, tuple, range, dict,
Python offers lists \bd{more like a vector}, immutable tuples, ranges\bd{irrelevant?}, sets, maps, and deques\bd{in separate collections package, move below?}
as basic collections.
Since Python 3.6, \code{dict} maintains insertion order and
% -  OrderedDict (going to be default)
makes the separate \code{OrderedDict} redundant.
To provide the ability to create a single view on multiple maps,
it offers \code{ChainMap}.
% frozenset
To enable sets of sets, it offers also a \code{frozenset},
which has the necessary support for obtaining a hash value.
% - queue (synchronized)
Similar to Racket,
it provides a synchronized queue abstraction
to facilitate communication between multiple threads.
%  - typed primitive arrays
To represent number types efficiently, it also supports typed arrays.
% bytes, bytearray (imm vs mutable)
A special case is here the \code{bytes} type,
which is an immutable byte sequence that is used for instance for byte literals.
\bd{Python has this funky not-encapsulated way to support priority queues, maybe worth mentioning?}
% https://docs.python.org/3/library/heapq.html

\paragraph{Dart 1.24}

% - lists, LinkedList, set, map, DoubleLinkedQueue, ListQueue, Queue
Dart's standard library includes lists, linked lists, sets, maps, list queues,
or doubly linked queues\bd{uh?}.
% - HashSet, LinkedHashSet, SplayTreeSet
% - HashMap, LinkedHashMap, SplayTreeMap
Sets and maps are available either using hash tables,
linked hash tables, or splay trees.
Similar to other dynamic languages,
% primitive type lists
Dart also offers lists of primitive types
for efficient representation in memory.

% Potentially TODO:
% - Eiffel, Pascal, Ada, ... other old-school stuff
% - Oz, Prolog, Erlang, ...
% - ML, Ocam, Ocaml, ...
% - other unconventional languages

\bd{Would a table to compare make sense here? Maybe kind of collection * languages = language type if any?}

\section{Design Dimensions for Collection Libraries}

Based on the observations of \cref{sec:col-wild},
this section distills the design dimensions for collection libraries. 

\subsection{Types of Collections}
\label{sec:col-types}

The first dimension is the types of collections to be included in the library.
Here, we abstract as much as possible
from general properties of collections (cf. \cref{sec:col-properties})
and other implementation or representation choices
(cf. \cref{sec:impl-choices}),
which we try to consider as orthogonal concerns
even so it is not always obviously beneficial.

% - array
% - list/vector, tuples, pairs, boxes
% - bags/multisets
Consequently,
the first category of collection types is \emph{bags or sequences}.
Considering ordering, mutability, sizing, and representation
as orthogonal concerns,
this category includes arrays, lists, vectors, tuples, pairs, and boxes.
Generally, these collections provide the ability to store elements
that are possibly repeating
and operate on them perhaps by direct access or via iteration of some sort.

% - set
The second category is \emph{sets}.
Thus, collections that do not maintain repeated elements
and only store a single occurrence based on some equivalence criterion.

% - map
% - multi-map
% - bidirectional map
The third category is \emph{maps}.
These collections store key/value pairs of some sort.
Languages such as Racket allow polymorphism between index collections and maps.\bd{not clear, be more direct: In Racket sequences can be seen as a special case of maps.}\sm{hmmm, but this is saying something different. What I say is they have the same interface. you say lists are a special case. Think what you say is too specific and not generally true (Racket needs the list to be a list of explicit pairs, while a vector is directly a \code{dictionary}).}
This could lead to an argument that ordered maps are sufficient to represent
any kind of sequence,
from which we refrain here even though Lua 5.0 only offers tables\citep{The_implementation_of_lua}.\sm{should I break this out and put this into the survey section?}\bd{Doesn't belong here, for sure.}

% - stack
% - queue
% - deque
% - priority queues
%   - heap
% - ring
The fourth category is \emph{stacks and queues}.\sm{better name?}
These collections store elements
and restrict the access in a way
that facilitates the efficient implementation of certain use cases.
We include here deques, priority queues or heaps, and rings.

% - matrix
% - table 
The fifth category is \emph{composed collections}.
These are collections that could be built by combining multiple collections.
We include here for instance matrices, which are two-dimensional arrays,
and tables, which are two-dimensional maps.
Again, these two could be considered of the same class
if indexing with integers is considered a associative access.

% - range/slice
% - range map/set
The six category is \emph{ranged collections}.
These seem to be rare in form of range maps or sets.
However, we include here the ranges or slices as well,
which are available in some languages
and correspond to a reified potential\bd{Why potential?}\sm{because they still need to be applied. It's a specification for where to iterate, I'd say. You got a better word?} iteration.

\subsection{Language Style}
\label{sec:language-style}

The second category that has a major influence on the overall collection design
is the language the library is designed for.

% - language style
%   - object-oriented, procedural, functional, ...
The \emph{language style} in terms of being procedural, object-oriented,
or functional leads to different designs in shape and structure of collections
as well as the provided sets of operations on them and the operation naming.

The language's stance on \emph{typing} and its support for type parameter
shapes libraries in various ways.
% primitive maps/sets, ...
%   - primitive as keys or values
%  - bit sets
In dynamically-typed languages,
we see the need for explicit support of collections for primitive types, \eg,
to store numeric data efficiently.
This includes basic sequential collections for numeric elements (\eg \code{Int32Array} in ECMAScript)
or primitive maps or sets (\eg \code{IntMap in Scala}).
\bddone{Unclear if this means specific types or transparent and supported by the VM}\sm{no, at this point we are not talking about any implementation tricks and only about explicitly supported things. I added examples, which hopefully clarify}
%      - templates
In typed languages,
we see typically some form of generics, type parameters, or templates,
which help to reduce a proliferation of collections for specific data types.
\bd{and imho make the API far more complex}\sm{? not sure what you mean?
You're saying Generics make APIs more complex? because of co/contra variance and stuff? sure, but typed languages need them. You want to add anything here?
Or is this a point that's useful later: generics are complicated/distracting because X, and thus, it seems that dynamically typed languages might have an edge for exploratory programming?}

In addition to typing, the \emph{reuse} mechanisms offered by a language have
an important impact on library structure.
For example, single inheritance can lead to designs with undesirable
properties as seen in the Smalltalk-80 collection library\citep{Cook:1992:ISS}.
While some of these issue can be worked around,
other reuse mechanisms such as traits,
might result in designs that have benefits\citep{Black:2003:ATS}.
% -> Smalltalk example \citep{Cook:1992:ISS}
%   -> if you only got single inheritance, only mechanism of reuse
%      that does not need composition (which might introduce other issues,
%      for instance performance overhead in interpreted languages)
%   -> subclassing not always ideal
%   -> some things are just not subclasses
%     -> deleting methods
%     -> providing other functionality via same name
%     -> structuring requires much care

In some case, languages have evolved to facilitate
desired collection library designs\citep{Chakravarty:2005:ATC,Garcia:2007}.
In other cases,
the library needed to evolve
and use the available language mechanisms more effectively
to improve maintainability and code reuse
as for instance in the case of Scala\citep{Odersky:2009}.



\subsection{Properties}
\label{sec:col-properties}

In addition to the basic operations and properties of collections,
they can also vary in additional properties.
As already noted in \cref{sec:col-types},
it is not always clear whether these properties are completely orthogonal
to the type of a collection.
Similarly, the properties we identified are not completely independent
of each other either.

\paragraph{Basic Properties}

% - fixed size/variable
For some of the collection types,
variants exist that have a \emph{fixed or variable size}.
For instance, sequences can be vectors with a variable size,
or arrays with a fixed size.
Similarly, queues might use a variable size implementation or a fixed sized to
enforce a bound on the upper queue length.

For many collection types,
there are variants that are \emph{ordered or unordered},
\ie, they maintain for instance insertion order.
Lists or other sequences do this commonly,
but it can be equally beneficial for maps, sets, and other collection types.

% - sorted (absolute, opt-in)
In addition to ordering, collections can \emph{sort elements}.
Some collections maintain a sorted order at any point in time,
while for other collections it is specifically requested.

\paragraph{Mutability}

% - mutability (mutable, immutable, read-only wrappers)
%  - absolute vs opt-in
% - persistence (persistent data structures, just an implementation technique for immutable collections? or does it have a design impact? probably, because of performance aspects)
% - copy on write

Collection libraries also offer collections that differ in their mutability.
Often there is the basic distinction between
\emph{mutable} and \emph{immutable} collections.
Languages such as Java, also provide partial immutability guarantees only
by offering \emph{read-only views} in form of wrappers for collections.

Immutable collections can further vary significantly in their implementation.
Some are implemented as \emph{persistent} data structures,
which use structural sharing to avoid high memory overhead when producing
new version of a collection with only minimal changes.

For some specific use cases,
we also see the use of \emph{copy-on-write} data structures
such as Java's \code{CopyOnWriteArrayList}.
These can be useful to provide isolation between multiple entities
and enable mutability,
while minimizing memory usage by employing structural sharing.

\paragraph{Multi-Threading Support}

% - concurrent (various different use cases for same collections)
% - parallel (for bulk operations, can also be realized via streams)
% - synchronized (just thread-safe wrappers)

To support various multi-threaded scenarios, 
collection libraries can include a multitude of different collection types.
The simplest solution to ensure correctness is
to provide \emph{synchronization wrappers} as done by Java and C\#.
However, these collections are really efficient
and often lack support for performing multiple operations safely together.
These problems are typically addressed
by specialized \emph{concurrent} collections,
which are optimized for specific use cases.
This often leads to a proliferation of collection types.
For instance queues can be optimized for various different use cases.
A queue for a single producer but multiple consumers can often be implemented
more efficiently than a queue for multiple producers.

For efficient bulk operations,
languages such as Scala provide \emph{parallel} collections,
where operations are executed in parallel.
Similar to sorting, where some collections do it intrinsically,
this is also a property that often is provided via operations
possibly external to the collection (cf. \cref{sec:operations}).

\paragraph{Other Properties}

% - weak
\emph{Weak} collections are commonly offered to build caches
and other data structures that interact well with garbage collection
by enabling reclamation of not otherwise referenced objects.

% - lazy vs strict
Languages such as Haskell offer the distinction between \emph{lazy and strict}
collections to provide control over when operations are executed.
However, this distinction is not exclusive to lazy languages.
In conjunction with iteration,
other languages often also offer the option to perform operations lazily.

% - identity-specific collections
%   - might be an optimization
%   - can generally be realized by parametrizable operations for example for comparisons or hashing

Finally, we observed collections such as sets and maps
that use \emph{identity} as main distinguishing criterion.
We presume that these collections are optimizations for a common use case,
because languages such as Java, Smalltalk, Dart would allow to construct
for instance maps that can be parameterized with appropriate operations
for comparison or hashing.

\subsection{Operation Design}
\label{sec:operations}

% - basic operations
The design of collection operations is likely influenced to a large degree
by the language style as mentioned in \cref{sec:language-style}.
On the one hand, this influences naming of operations,
on the other hand, it influences which operations might offered,
how bulk operations are offered, or how error handling is done.
To give just one example, in Smalltalk it is common to pass closure as arguments
to operations that might fail to provide the failure handling code directly.
In other languages, return codes or exceptions are used to indicate failure
that has to be handled externally to the collection.

% - sorting
There are other previously mentioned aspects
that influence the offered operations including immutability, persistence,
sorting, parallel bulk operations, laziness, iteration in general,
and possibly properties that are realized as some form of opt-in mechanism,
which may include immutability and read-only views.

% - polymorphism
%   - compatibility of collections
%     - maps as lists (iteration), lists as maps (int->T maps)
%     - immutable/mutable...
%     - use of wrappers?

One important aspect of designing the interfaces of collections is the intended
degree of polymorphism,
\ie, whether collections should offer the same interfaces.
To facilitate code reuse, one might want to design collections
that have different properties such as being mutable or immutable
in a way that still allows them to be used interchangeably.
One way of doing this is by using decorators or wrappers around collections
that add the desired properties, \eg, basic synchronization in Java.
Other options to consider are whether maps should be iterable
in the same way as sequences, or whether sequences can be treated as maps.

%- bulk operation
%  - order guarantees (everything modeled as lists)
%  - processing (sequential, parallel, lazy)
%  - slices
%  - internal/external iteration
%    - streams
%    - queries (linq)
%    - navigation (navigable Java)

Iteration or more general collection traversal is an important design point.
The basic properties ordering and sorting sorting need to be taken into account.
Furthermore, iteration operations need to consider whether processing is
to be done sequentially, in parallel, or lazily.
Languages with slices or ranges can use these as interface
to defined how to iteration.
Finally, other concepts such as internal iteration, streams,
and language-integrated query (LINQ)
influence the set of offered operations further.

\subsection{Algorithms, Data Structures, and Implementation Choices}
\label{sec:impl-choices}

The final set of design dimension are implementation choices,
which included the selection of a specific algorithm or data structure
to realize a collection.

Literature is known to include a large variety of special purpose
data structures, especially for concurrent applications.
However, there seem to be a few favorites that are recurring.
For
% - trees
% - tries, splay trees
% - skip lists
% - singly/doubly linked lists
trees we saw for instance red-black trees, tries, and splay trees,
for lists singly and doubly-linked ones, array-based, and skip lists,
% - specialization for stable, static, small vectors/lists
possibly with specializations for small or rarely changing lists.
%
% - specializations for small dicts
The concrete algorithms for hash tables are not usually specified
in the documentation.

% - wrappers for properties
Another important design dimension mentioned before is
how the various properties of collections are represented.
Some libraries provide separate classes for each possible type and property,
while others realize the desired properties with decorators,
\ie, wrapper constructs.

\section{Collection Usage}

As seen in the previous section,
collection libraries differ widely
in the number of collection types they provide
and the properties these collections can offer.
Especially Java provides a multitude of different collection types and still,
the wider community felt the need to provide and maintain libraries
for additional collections.
One important question to guide the design could therefore be,
which collection types are widely used and are likely going to be needed
for exploratory programming tasks.

To answer the question of which collection types are widely used,
\citet{Costa:2017:ESU} studied a GitHub corpus of Java projects\citep{6624029}.
They found that most instantiation sites for collections
create \code{ArrayList} objects.
From all sites analyzed, 47\% used the standard Java \code{ArrayList}.
Overall, about 56\% used some kind of list.
Maps where used by about 28\%,
where the great majority uses Java's \code{HashMap},
which results in a total of about 23\% of all allocations.
About 15\% all instantiation sites were for some set type.
Again, the large majority was for Java's \code{HashSet}
with about 10\% of all allocations.

The only other study of the usage of collections we are aware of
was included in work by \citet[sec. 9.2]{Bergel:2018}.
They observed that \code{OrderedCollection} (similar to \code{ArrayList})
and \code{Dictionary} (a map) are the most frequently used collections
in some larger Pharo Smalltalk projects.
While the study is less comprehensive than the Java one,
it confirms the general trend.
Interestingly, it also considers arrays\bd{What arrays? OrderedCollection or built-in Smalltalk arrays? Or primitive arrays?}
and finds that they are used slightly more often than \code{Dictionary}.


\section{Techniques for Efficient Implementations}


\begin{note}
  TODO: add M. Steindorfer as reference for complex immutable/specialized data structures \citep{Steindorfer:2015:OHM}
  
  
  what is required in terms of efficiency?
  compilation-time feedback - needs to be fast to compile
  run-time performance - needs to be fast to execute

  \citep{Rein:2016:LLP} should look a little more into this one for terminology
  
Discussion Points:
 
Practical Implementation Concerns
 How to realize all this with same efficiency as when using special purpose
 collections?
 - probably not getting there 100\%, but 90\% or even 80\% are sufficient
   when it improves developer productivity (which still has to be proven of course)
  
 - to get to the 80-90\% mark
  -> strategies (seq, par)
   - Storage strategies for collections in dynamically typed languages \citep{Bolz:2013:SSC}
   -> concurrency strategy paper
  -> JIT Data Structures
     -> the other paper about collections I saw (something from a german university)

  -> CollectionSwitch: A Framework for Efficient and Dynamic Collection Selection
DOI 10.1145/3168825
CGO 2018 (to appear)
  -> cameleon, ... (JIT DS references)
% \url{https://www.researchgate.net/publication/322438185_CollectionSwitch_A_Framework_for_Efficient_and_Dynamic_Collection_Selection

- Tobias Pape's paper, for functional data structures


- compiler for static languages can do certain optimizations ahead of time:
  - compiler-level specialization as with miniboxing \citep{Ureche:2013:MIS}
  - C++ templates (expanding ones), eager specialization

How to design so that specialized collections remain possible?
And are easily adopted?
 -> ensure subset of collection APIs are polymorphic
   -> ideally, one just changes the constructor, or adds a conversion
   -> idea would be that this gives the last 10-20\% of performance when needed
   -> leave door open for improving performance by restricting flexibility
\end{note}


\section{A Collection Design for Exploratory Programming}

\begin{note}
  - Generalization vs. Specialization  
  - small set of generalized collection types 
  - or large set of specialized types
  
  - is small and versatile bad design because it violates the `one thing does   one thing good premise'
    - are those classes blobs? \citep{brown1998antipatterns}
    - do they do too much? is this an issue?
     -> yes, it's an issue, the code is not clear about what kind of 
        interactions one wants to allow on the collection
     -> complexity of implementation is a real issue (concurrency issues,
        strategies, JIT DS...)
     -> this means, it can be a burden for maintaining large systems
     -> it is a burden for VM maintenance
     -> however, The Blob anti-pattern combines complex state and behavior
        such collection design is not a direct instance of it, because
        the contained data is usually still used for a single purpose and
        it is merely that the collections themselves offer too much
        functionality

    - benefits of specialized classes:
      - chose specific implementation/algorithm/data structure
      - some people argue that programs are better understood if these things are explicit: \citep{PeytonJones:1996:BTC}
        -> """The type of the object does not specify its invariant (\eg in a set there are no duplicates) and its expected operations (\eg lookup in a infinite map). The lack of these invariants makes the program harder to understand, harder to prove properties about, and harder to maintain."""
        -> generic data structures (lists in case of Haskell) might not be optimal
         -> PJ already talks about 2.3 Adaptive representations
         A probabilistic approach to the problem of automatic selection of data representations \citep{Chuang:1996:PAP}
          -> markov processes

      - example
        -> set/map: implemented as tree or hash table?
        -> linked list or array list, or linked segments?
        -> can't make a right choice without knowing exactly what
           run time load is going to be

    - drawback of too specialized classes:
      - can become inflexible
        -> need conversion or adapters to perform certain operations
        -> large class hierarchies, hard to chose one, might not even be
           clear what options are available, or appropriate for problem


Example for complexity of types:
 - scala, type signatures are very complex
   -> documentation presents a simplified version to hide some of the complexity
   
  
\end{note}



\section{Related Work}
\sm{not sure we need this section}

\citet{Odersky:2009} describe their experience
redesigning the collection library in Scala.
Their focus is mostly on how they achieved an implementation and design
that is more principled, structured, and avoids code duplication
to avoid bit rot during future maintenance.
The library itself falls into the category of large and specialized (cf. \cref{sec:scala-col}). 

\citet{Matthes:2000:BT} investigate the question of how to design \emph{bulk types}, i.e., collection libraries, on the intersection to database systems and database programming languages.
They discuss the benefits and drawbacks of builtin or library-based designs and favor library-based designs for their extensibility.
\sm{discussion in paper context: assume we have good knowledge from the various languages and libraries what is necessary, assume that extensibility is not a problem either, because the languages could be dynamic and therefore lent itself naturally to simply changing the collection implementation if required.
Though, there might be limitations to what can be changed without interfering with optimizations such as strategies\todoref{}.}


Live Data Structure Programming \citep{Oka:2017:LDS}
- visualization
- generic data structures

\section{Conclusion}

C has the most minimal collection library, 


While I have convinced myself
that I do prefer the programming style offered
by a small and versatile collections library,
I cannot shake the feeling
that this is a post hoc justification
for the complexity we add to VMs.


%% ATTIC, Notes on Things Considered, but not included
%% ===================================================

%% Streams
%%
%% finite, or infinite sequence of values
%% aren't collections, just one way to express iteration/transformation

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\end{document}
