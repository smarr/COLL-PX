%% White space:
%% sentence parts on separate lines

% TODO: add review
\documentclass[sigconf, english]{acmart}
%\documentclass[sigconf, 10pt, review]{acmart}
% \documentclass[sigconf, 10pt, authordraft]{acmart}
\settopmatter{printfolios=true,printccs=true,printacmref=false}

\def\Title{Few Versatile vs. Many Specialized Collections}
% \def\ShortTitle{}
\def\SubTitle{How to design a collection library for exploratory programming?}
\def\PdfTitle{\Title: \SubTitle}
\def\PdfSubject{Collection Design for Exploratory Programming}
\def\PdfAuthors{{Stefan Marr, Benoit Daloze}}
\def\PdfKeywords{Collection Libraries, Design, Implementation, Exploratory Programming}

\def\SOMns{SOM{\sc ns}\xspace}
\def\LangCnt{14\xspace}

\include{scripts/init}


\collabAuthor{bd}{green!60!black}{Benoit}
\collabAuthor{sm}{red}{Stefan}

\usepackage{px18}
\usepackage{booktabs} % For formal tables

\usepackage{balance} % for \balance in references

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

\acmDOI{} % TODO
\acmISBN{} % TODO

%Conference
\acmConference[PX/18]{Programming Experience Workshop}{April 2018}{Nice, France}
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{}
\acmSubmissionID{}

\begin{document}
\title{\Title}
% \titlenote{Produces the permission block, and
%   copyright information}
\subtitle{\SubTitle}
% \subtitlenote{The full version of the author's guide is available as
%   \texttt{acmart.pdf} document}

\author{Stefan Marr}
\orcid{0000-0001-9059-5180}
\affiliation{%
    \department{School of Computing}
    \institution{University of Kent}
    \city{Canterbury}
    \postcode{CT2 7NZ}
    \country{United Kingdom}
}
\email{s.marr@kent.ac.uk}

\author{Benoit Daloze}
\affiliation{%
    \department{Institute for System Software}
    \institution{Johannes Kepler University Linz}
    \streetaddress{Altenbergerstra√üe, 69}
    \city{Linz}
    \postcode{4040}
    \country{Austria}
}
\email{benoit.daloze@jku.at}


% The default list of authors is too long for headers.
% \renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
While an integral part of all programming languages,
the design of collection libraries is rarely studied.
This work briefly reviews the collection libraries of \LangCnt languages
to identify possible design dimensions.
Some languages have surprisingly few but versatile collections,
while others have large libraries with many specialized collections.
Based on the identified design dimensions,
we argue that a small collection library
with only a sequence, a map, and a set type
are a suitable choice to facilitate exploratory programming.
Such a design minimizes the number of decisions programmers
have to make when dealing with collections,
 % avoids many upfront implementation decisions
% \bd{implementation decisions is not clear here, so I added `upfront' but maybe still unclear}
and it improves discoverability of collection operations.
We further discuss
%% SM: removed from abstract, because it isn't separate section
% that such libraries can be
%sufficiently
% supported with feedback mechanisms from development environments
% and consider
techniques
that make their implementation practical from a performance perspective.
Based on these arguments,
we conclude that languages which aim to support exploratory programming
should strive for small and versatile collection libraries.
% \bd{Or provide a convenient collection library to users? Seems very restrictive, only exploratory programming.}
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008.10011024.10011028</concept_id>
<concept_desc>Software and its engineering~Data types and structures</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011024.10003202</concept_id>
<concept_desc>Software and its engineering~Abstract data types</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10002944.10011122.10002945</concept_id>
<concept_desc>General and reference~Surveys and overviews</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Data types and structures}
\ccsdesc[300]{Software and its engineering~Abstract data types}
\ccsdesc[300]{General and reference~Surveys and overviews}

% TODO
\keywords{Collection Libraries, Design, Implementation, Exploratory Programming}

\maketitle


\section{Collections for Exploratory Programming}

% Context: What is the broad context of the work? What is the importance of the general research area?
% - collection libraries
%   essential part of any general purpose language
%   - C doesn't have one?

Collections or containers are part of all general purpose languages.
They are data structures that abstract over the number of data items
and allow operations over the contained items as a whole or individually.

% Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?

While being fundamental to most languages,
the design of collection libraries varies greatly.
At one end of the spectrum, we have C, which has only arrays.
At the other end, we have for instance Java,
with a standard library that includes dozens of collection abstractions,
and with external libraries to support different programming styles,
application scenarios, or performance requirements.

% - library design has major influence on
%   - language style/idioms
%   - programmer productivity (assumed)
%   - feeling of the language
% - as far as we are aware no systematic study
To the best of our knowledge,
there is no study on how the design of a collection library
influences programmer productivity
or the suitability of a language for exploratory programming.

% Approach: What was done that unveiled new knowledge?
% - explore design space
%   - which aspects need to be considered
%   - which design dimensions are there
The goal of this work is to identify the aspects
that need to be considered for the design of collection libraries
for exploratory and live programming.
%
%
% Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
%- reason about design space for a language designed for exploration
% - high flexibility
% - low friction
%   - avoid making unnecessary decisions,
%   - performance not important
%   - problem first needs to be understood
% - interactive program development
% -> live programming
Thus, we reason about the design space for collections
and how different design choices may influence the programming experience.
Our analysis relates these design choices to the main programming task,
%\sm{avoid making unnecessary decisions},
performance, and the programming experience.
% \sm{feedback potential}

% Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?
%- argue for feasibility based on existing techniques
To get an overview of the design space,
we discuss the high-level design of collection libraries for
C, C++, Go, Java, C\#, Scala, Haskell, Racket, Pharo Smalltalk, Ruby, JavaScript, Python, Dart, and Lua.
From this overview, we extract design dimensions and 
argue for specific choices in the context of exploratory programming.
We also review implementation techniques
to support the design's practicality
in terms of achieving the same performance as alternative choices.

% Therefore, this paper\sm{somewhat a contribution statement, but also redundant with the above. Revisit before submission.}
%
% \begin{itemize}
%   \item describes the design space for collection libraries
%   \item discusses design choices and their suitability for exploratory programming
%   \item reviews implementation techniques to ensure practical performance
% \end{itemize}
%
% Importance: Why does this work matter?
% - collections are complex but essential parts of our languages
%   - better understanding will enable more principled design
While not exhaustive, we hope this analysis provides an insight
into the complex design space of collection libraries
and their relation to the programming experience itself.
Our immediate goal was to better understand the tension between design choices
for the design of a collection library for \SOMns, a Newspeak implementation\citep{Bracha:10:NS,OptCELWithTruffle}.
Newspeak follows in many ways previous Smalltalk systems
and as such has a large and specialized collection library.
However, based on the arguments presented here,
we believe that a small and versatile library would be more appropriate
for a language that itself is quite suitable for exploratory programming.


\section{Live and Exploratory Programming}
\label{sec:exploratory}

Before diving into the details of designing collection libraries,
we discuss the terms live and exploratory programming
to clarify our assumptions and the context of this analysis.

% - need a brief discussion of what our assumptions are
% - what are the ``requirements''?
% - four levels: \citep{Tanimoto:1990:Viva,Tanimoto:2013:PEL}
%   level 3:
%    - changes update programs
%      -> system might attempt reexecution, possibly only relevant parts
%   level 4:
%    - continuous feedback in time-varying results based on current program

For the term \emph{live programming}, we rely on \citeauthor{Tanimoto:1990:Viva}'s notion.
Specifically, we aim to support programming
with immediate updates and feedback from the programming environment.
This might be either triggered by edits or presented as continuous event streams,
which corresponds to liveness of level 3 or 4\citep{Tanimoto:1990:Viva}.
While generally desirable, we forgo considering more advanced liveness levels
that include predictive features, \ie, level 5 and 6\citep{Tanimoto:2013:PEL}.

%  - feedback on valid programs
%  - feedback on execution
Based on these liveness level and on the work of others\citep{McDirmid:2007:LUL,Burckhardt:2013:ACF,Rein:2016:LLP},
we expect programming environments and languages
to improve the programming experience by providing immediate feedback on
the validity of programs and code execution.
This feedback should be meant to reduce the friction
that is inherent in the communication between humans and machines,
which is constrained by artificial languages and machines
that still neither perceive the context of a conversation nor learn from interaction.
To work around these limitations,
we expect machines to support the communication with feedback,
limited forms of understanding,
and a basic robustness to invalid communication.

%% Feedback
% - want feedback on valid operations in terms of
Feedback should be provided in form of
%   - code completion, documentation
code completion, contextual documentation,
%   - error highlighting (unsupported methods)
syntax errors, highlighting of possibly invalid method calls or operations,
style violations, and generally undesirable patterns.
% - edit/feedback latency
%   - feedback should be fast, overall execution fast enough
% - state snapshots, reexecution, redisplay
% - should not prevent state snapshots (seems orthogonal)
% - possibility of continuous feedback
%   (seems to be orthogonal, but should not be prevented)
The analyses that enable such feedback need to be implementable
in an efficient manner to give the illusion of instantaneous feedback.
%
%% Understanding
% - implicit over explicit, for types
%   - types inferred or dynamic
With limited forms of understanding,
we refer essentially to analyses
that allow programmers to be more implicit than explicit in their programming.
One aspect of this is typing.
Languages that use type inference
or tool-based feedback seem to facilitate exploratory programming better
than languages that require us to make such aspect explicit.
%   
%% Robustness
% - error recovery, robustness, non-interference of irrelevant parts
% - program errors in unrelated/unexecuted parts need to be ignored
The overall system should also be robust with respect to programming errors.
Especially errors in unrelated program parts,
or parts that are not executed
should not inhibit our ability to interact with the system,
explore, and extend it.

%% 
Generally, when exploring a problem and experimenting with solutions,
we want to focus on the problem domain and prioritize the core aspects
while deferring for instance overall application performance,
handling of exceptional cases,
or the completeness of a solution to a later point.
Thus, the programming environment should not force us to make decisions upfront,
for which we do not understand the problem well enough yet
or for which we would predict highly inaccurately
how an algorithm is used in production scenarios.
Types or structural elements often help exploring
the problem and organizing thoughts,
but should not prevent or hinder us from exploring it.

% - focus decision making on problem and domain
%   - application performance secondary concern,
%    as long as feedback is not impaired 
% - types or at least structure might still be helpful to organize ones thoughts
Since collections provide bulk operations
and are relevant for acceptable performance,
run-time performance needs to be considered,
even though it is a secondary concern.
% While it is not of highest priority for application performance,
% it should also not impede live feedback.
%% SM: we don't talk in enough detail about analyses, so their performance
%% is also something we don't go into

\section{Collection Design in the Wild}
\label{sec:col-wild}

% - having a brief look around, informally, just getting a flavor
%  - what collections do they contain
%  - how large (num classes/concepts) are libraries
%  - any particularly interesting things?

Collection libraries are as diverse as languages are different.
% There is a multitude of design dimensions that can be varied.
There are many design dimensions to consider.
Some dimensions are influenced by the underlying language,
its basic abstractions,
as well as what is considered desirable programming style, \ie, idiomatic code.
Other dimensions include the set of offered collection types,
implementation strategies (usually differing in space/time tradeoffs),
or general properties such as synchronization, modifiability, ordering,
sorting, and constraints in general.
%
This section briefly reviews collection libraries of \LangCnt languages
to identify the provided collection types
and high-level design differences.
The set of analyzed languages is not exhaustive but includes different types of languages
that are widely used and have been applied to many application domains.

\paragraph{C11}

% - C
%   - array
% - GNU libc: hsearch, tsearch

% C, one of the most widely used languages, is an interesting case as t
The C11 standard includes only a single collection type: arrays.
In comparison to other languages, C arrays are merely raw memory.
They neither include a length nor any form of safety checks,
and thus represent the minimal possible abstraction.
% that could be provided.
The \citeurl{GNU C Library}{The GNU C Library (glibc)}{GNU Project}{}{https://www.gnu.org/software/libc/manual/}
expands only minimally on arrays
by providing hash table and tree-based operations on arrays
for searching and sorted access.

\paragraph{C++17 and Boost 1.66}

% - C++
%  - sequences
%   - array, vector, deque, forward\_list (singly linked list), list (double)
% 
%  - associative
%   - set, map
%   - also unordered
% 
%  - adapters
%    - stack, queue

C++17\citep{Cpp17} expands on C
by providing a template-based standard library (STL).
% BD: link to the documentation: http://en.cppreference.com/w/cpp/container ?
It includes C arrays but also an STL version, which can do bounds checking.
Additionally, it includes vectors, deques, singly and doubly linked lists,
sets and maps in an ordered (tree-based) and unordered (hash-based) variant,
as well as adapters to realize stack or queue semantics.
Generally, the STL remains comparably lean,
but already provides collections with different performance tradeoffs
that enable programmers to choose based on their expected usage scenarios.

% Boost C++
%  - expands with specialized containers,
%    mostly specific to C++ language constrains
%    - and different representation tradeoffs
%    - different vector classes (stable, static, small)
%    - flat sets/maps (instead of using trees)
%      - worse at insertion but faster lookup
%    - heap (priority queues)
%    - collections packing objects by type (for performance) PolyCollection
%  -> indicates that here performance is main driver for variability
The \citeurl{Boost C++ libraries}{Boost C++ Libraries}{boost.org}{}{http://www.boost.org/}
expand on the STL by adding more specialized containers,
which at least partially address C++-template-specific issues.
The variations on the vector class address different performance tradeoffs.
%Similarly, the tree-based sets and maps of the STL are complemented
%with hash-based implementations. \bd{std::unordered\_map is a HashMap!}
Overall Boost seems to focus on optimized collections
for specific use cases.

\paragraph{Go 1.9}

% - Go
%  - arrays, slices, maps (http://www.golangbootcamp.com/book/collection_types)
%  - heap, list, ring (from where?)
%  - no sets

The \citeurl{Go language}{The Go Programming Language}{Go Project}{}{https://golang.org/}
comes with abstractions for arrays,
%slices \bd{slices are just a view of arrays it seems, can we settle on a common terminology for this?},
lists, rings, maps, and heaps.
The library includes only the basic abstractions needed.
For instance, it does not contain a separate set type,
perhaps because it can be easily modeled based on maps.

\paragraph{Java 8, Guava 24, and Eclipse Collections 9.1}

% - Java
%   - arrays

In contrast, \citeurl{Java}{Java SE 8}{Oracle}{}{https://docs.oracle.com/javase/8/}
has a large collection library.
% array
As basic abstraction, the language includes arrays,
which can be of different primitive or object types.
% map, list, set, deque, stack
Its standard library provides implementations for a wide variety of collections
including lists, maps, sets, queues, deques, priority queues, stacks,
% - iterators
and iteration abstractions.
% \bd{Are iterators relevant? It's just a way to access containers, no?}
% SM: yes, iterators are relevant
Many of the collections come in different variations.
% - hash map/set, tree map/set
For maps and sets, there are hash and tree-based implementations.
% - lists: linked, array
Lists are implemented for instance as linked or array lists,
% - skip list, CopyOnWriteArrayList
which is then complemented with skip lists, or copy-on-write lists.
Depending on the collection type,
% - ordered collections
% - navigable collections
% - readonly/unmodifiable collections
% - weak collections
there are also variations that
provide ordering guarantees, sorting, make them navigable,
enforce read-only access, reference elements only weakly,
or give guarantees for concurrent accesses.
% - concurrent collections
Concurrent accesses can be synchronized
with a basic synchronization wrapper
or by using a specific data structure
that might have less synchronization overhead
or allows for more parallelism.
%
As a result,
the standard library provides a large number of collection implementations.
While some properties are provided by wrappers
and allow for combination,
many collections are separate implementations tuned for specific use cases.

% \subparagraph{Guava 24}

% - Guava
\citeurl{Guava}{Guava: Google Core Libraries for Java}{Guava Project}{}{https://github.com/google/guava/wiki/NewCollectionTypesExplained}
%  - extension, keeps compatibility and set of concepts (for many elements)
%  - iterators
extends the Java collection library with additional utility methods
% , while keeping basic compatibility.
%  - multiset, multimap, bimap, table (2 nested maps), RangeSet, RangeMap
and adds
% new collection types including 
multi-sets, multi-maps,  bidirectional maps, tables, as well as range sets and maps.
%  - immutable collections (more optimized over unmodifiable)
Furthermore, it adds immutable versions of the basic collection.
The focus is on more efficient in-memory representations
and improving performance for access operations
compared to Java's read-only/unmodifiable collection wrappers.

% \subparagraph{Eclipse Collections 9.1}

The \citeurl{Eclipse Collections library}{Eclipse Collections}{Eclipse Foundation}{}{https://www.eclipse.org/collections/}
% extension, keeps compatibility and set of concepts (for many elements)
also extends the Java collection library.
% keeping basic compatibility.
% - BiMap, Bag, Multimap
Similarly to Guava, it adds bidirectional maps, multi-maps, bags,
and provide additional utilities.
% rich iteration operation, incl. lazy and parallel iteration
This includes rich support for iteration
for instance to iterate lazily or in parallel.
%    - mutable and immutable collections
It also adds immutable collections.
% - specializations for primitive types
Additionally, it provides specialized collection types for primitive types
to avoid boxing overhead of Java's collection types.
% \bd{Which multiplies the number of collections and is tons of duplicated code!}


\paragraph{C\# and .NET Framework 4.7}

Similar to Java, \citeurl{C\# and the .NET Framework}{.NET API}{Microsoft}{}{https://docs.microsoft.com/en-us/dotnet/api/?view=netframework-4.7.1}
%  - arrays
%  - ArrayList, BitArray, Dictionary (hashtable), queue, stack, HashSet,
%    LinkedList
have arrays, lists, sets, maps, queues, and stacks.
While the framework includes linked and array lists,
it does not include explicit tree sets or maps.
%  - ordered collections
However, it also includes sorted collections,
which might be implemented as trees, but the documentation refrains from
specifying the performance of operations or naming an implementation technique.
%  - read only collections (just wrapper, not truely immutable, just a readonly view)
%  - immutable (persistent/structural sharing)
Similar to Java, C\# provides read-only, \ie, unmodifiable collections,
which are wrappers.
Additionally, it provides immutable collections,
which are implemented as persistent data structures, \ie,
use structural sharing.
%  - concurrent collections
%  - synchronzied collection
For thread-safety,
it offers synchronization wrappers
as well as special-purpose concurrent collections
with better concurrent behavior.
%
%  - iterators, query support
One feature specific to C\# and .NET
is the support for query operations on collections with LINQ\citep{Meijer:2011:WAL},
which are an addition to the traditional iteration operations.

\paragraph{Scala 2.12}
\label{sec:scala-col}

\citeurl{Scala's standard library}{Scala Standard Library}{EPFL}{}{http://www.scala-lang.org/api/2.12.4/}
% comes with collections somewhat similar to Java.\bd{I know some who would disagree...}
% - maps, sets, sequences
% - arrays
supports arrays, maps, sets, and sequences as basic abstractions.
% HashMap, HashSet, TreeMap, TreeSet, ArraySeq, DoubleLinkedList
It has hash and tree-based versions for sets and maps
as well as array-based or doubly linked lists
to cover the main implementation strategies.
%  - BitSets, , ListMap, LinkedHashMap/Set, MultiMap, Queue, Range, Stack, Stream, Vector, WeakHashMap
It has special-purpose collections
such as bit sets, list maps, integer maps, linked hash maps or sets, multi-maps,
queues, stacks, vectors, and weak hash maps.
% The library is however structured differently.
% - mutable
% - immutable/persistent
The library offers mutable and immutable versions
of most collections.
The immutable collections are typically implemented
as persistent data structures with structural sharing.
Both types of collections are polymorphic on read operations,
which makes them interchangeable for basic accesses.
Additionally, the library provides concurrent, sorted,
and parallel versions of some of the collections.
The parallel collections focus on parallel execution of bulk operations.

% - iterators
% - concurrent
% - sorted collections
% - parallel
%    - has collection framework with mutable and immutable collections
%      -> the have the same basic structure
%      -> APIs facilitate the same programming style
%      -> since Scala embraces OO and FP, this seems not surprising
%
%    - uniform return type principle \smtodo{was this in \citet{Odersky:2009}?} \url{https://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html}
%     The Architecture of Scala Collections

\paragraph{Haskell}

% - immutable collections
%   - lists basic builtin type
%   - tuples

Haskell offers only immutable lists and tuples as builtin types.
Other collections are provided as external packages.
% \bddone{stdlib or really packages to install separately?}\sm{I clarified this a little, but don't think I want to break this out into separate things. not worth it. Also very different from the Java libraries}.
The \emph{base} library,
% - concurrent queue (Chan)
which is the standard library for the Glasgow Haskell Compiler (GHC)
only contains channels, \ie, concurrent queues.
The \emph{containers} library, the de-facto standard collection library,
provides sequences, maps, graphs, sets, trees, and bit queues.
Some of these are provided as lazy or strict variants.
% to give programmers more fine-grained control.
Similarly, it provides special sets and maps for integers,
presumably for performance reasons.

% - containers library
%   - sequences (different performance than lists)
%   - map, graphs, sets, tree
%   - integer collections (sets, maps)
%   - lazy or strict
%   - BitQueue

\paragraph{Racket 6.12}

% - Pairs and Lists (immutable versions prefered)
\citeurl{Racket}{The Racket Reference}{Racket Project}{}{https://docs.racket-lang.org/reference/} provides pairs and lists in the Scheme tradition.
% - Vectors
% - Boxes (1-elem vector)
% - Hash Tables
% - Sets
In addition, it provides vectors, boxes, hash tables, and sets.
% boxes \bd{uh?} 1-element vectors.
% - immutable versions
Most collections are available as immutable and mutable variants.
% \bd{differentiated by name or package?}
% SM: yes, different names/packages, depends a little
% - channels (synchronized)
To support concurrency, it provides channels.
Buffered channels are synchronized queues.
%\bd{confusing}

\paragraph{Pharo 6}
Pharo's collection library is based on the collection library
of Smalltalk\citep{Smalltalk80,Cook:1992:ISS}.
% HashedCollection, Array, bags, stack, set, bag, Matrix, DoubleLinkedList
It includes arrays, maps, sets, bags, stacks, matrices, and doubly linked lists.
% - OrderedCollection, OrderedDictionary
% - SortedCollection
% - IdentityDictionary, IdentityBag, IdentitySet
Some collections are available in variants that are ordered, sorted,
or based on identity.
% primitive arrays
It also offers arrays of primitive types that store raw values in memory.
% SmallDictionary, SmallIdentityDictionary
Small maps can use classes that are specifically optimized for this purpose.
% - concurrent collections (LIFOQueue, WaitfreeQueue, AtomicSharedQueue)
% - weak collections
Similar to other languages,
it includes weak collections as well as a number of queues for concurrent use.

\paragraph{Ruby 2.5}

% With respect to the number of collection types offered,
Ruby's collection library is comparably small.
% - Array, Hash,
Its main collection types are arrays and maps.
Instead of offering lists, deques, or stacks as separate collections,
\code{Array} supports the corresponding operations.
% - Queue, SizedQueue, WeakMap, Range
The \code{Hash} map always maintains insertion order,
and can be instructed with \code{compare_by_identity} to use identity of keys.
% \bd{Same for compare-by-identity, it's a flag within Hash, but too much details perhaps, although nice anecdote?}
Ruby also provides variable size and bounded queues for multithreading and a range abstraction.
% \bd{Not a collection? Go and others also supports ranges, but seems irrelevant},
%and weak maps. % BD: that's internal (ObjectSpace::WeakMap) and seems not used, only WeakRef at the user-level
% - freeze, sort
Immutability of collections is supported by Ruby's mechanism to freeze objects.
% , \ie, to make them immutable.
Sorting is not provided as part of separate collection types either.
Instead \code{Hash} and \code{Array} have a \code{sort} method.
% \bd{Note: Hash too, it's Enumerable\#sort, which always return an Array}
Ruby's collections provide many internal iteration
and transformation methods so that external iteration is rarely used.
%and considered unidiomatic.
%\bd{Should mention Enumerable contains 56 general iteration+transformation methods for all collections based on \#each? Or Array has 101 methods so iterating loops/iterating by index is rarely needed in Ruby and most used cases are built-in?}
%\sm{something like the above?}

\paragraph{JavaScript, ECMAScript 2016}

% Array, Object
JavaScript's collection library used to offer merely
arrays and objects, which could be used as maps but only accept strings as keys.
% map, set
Since this was limiting,
newer versions of the ECMAScript standard introduced maps, sets,
% - WeakMap/WeakSet
and their weak counter parts.
% - primitive arrays (TypedArray), views for byte-based ArrayBuffers
They also introduced typed arrays, \ie,
views on raw memory that allow representing certain number types
directly in memory.

\paragraph{Python 3.6}

% https://docs.python.org/3.6/library/collections.html

% - deque, set, list, tuple, range, dict,
Python offers lists,
% \bd{more like a vector}
immutable tuples, ranges,
% \bd{irrelevant?},
sets, and maps as basic collections.
Since Python 3.6, \code{dict} maintains insertion order and
% -  OrderedDict (going to be default)
makes \code{OrderedDict} redundant.
To provide a single view on multiple maps,
it offers \code{ChainMap}.
% frozenset
To enable sets of sets, it includes a \code{frozenset},
which has the necessary support for obtaining a hash value.
Priority queues and deques are also provided in standard modules.
% - queue (synchronized)
Similar to Racket,
it provides synchronized queues
for communication between threads.
%  - typed primitive arrays
To represent numbers efficiently, it also supports typed arrays.
% bytes, bytearray (imm vs mutable)
A special case is here the \code{bytes} type,
which is an immutable byte sequence that is used for instance for byte literals.

\paragraph{Dart 1.24}

% - lists (vector), LinkedList (doubly), set, map, DoubleLinkedQueue (linked deque), ListQueue (array deque), Queue
Dart includes lists, deques, sets, maps and queues in many variants.
% - HashSet, LinkedHashSet, SplayTreeSet
% - HashMap, LinkedHashMap, SplayTreeMap
Sets and maps are available either using hash tables,
linked hash tables, or splay trees.
Similar to other dynamic languages,
% primitive type lists
Dart also offers lists of primitive types
for efficient representation in memory.

% Potentially TODO:
% - Eiffel, Pascal, Ada, ... other old-school stuff
% - Oz, Prolog, Erlang, ...
% - ML, Ocam, Ocaml, ...
% - other unconventional languages

% \bd{Would a table to compare make sense here? Maybe kind of collection * languages = language type if any?}
% SM: yes, but not in this paper.

\paragraph{Lua 5.3}
\label{sec:lua53}

\citeurl{Lua}{Lua 5.3}{Lua.org}{}{https://www.lua.org/manual/5.3/}
is designed as a lightweight language for embedding and scripting.
The lightweightness is made explicit also in its approach to collections.
The only abstraction it provides is a table, which is an associative array,
but also used as basic abstraction for object-oriented programming.
Consequently, tables are used for sequences and maps
and have been optimized
to fulfill both types of usages\citep{The_implementation_of_lua}.

\section{Design Dimensions for Collection Libraries}
\label{sec:dimensions}

Based on the observations of \cref{sec:col-wild},
this section distills the design dimensions for collection libraries. 

\subsection{Collection Types}
\label{sec:col-types}

The first dimension is the \emph{collection types} to be included in the library.
We abstract %as much as possible
from general properties of collections (cf. \cref{sec:col-properties})
and other implementation or representation choices
(cf. \cref{sec:impl-choices}),
which we consider as orthogonal concerns
even so it is not always obviously beneficial.

% - array
% - list/vector, tuples, pairs, boxes
% - bags/multisets
The first category of collection types is \emph{sequences}.
% \bd{bags are not even cited below}
% SM: no, bags belong in here
Considering mutability, sizing, and representation
as orthogonal concerns,
this category includes arrays, lists, vectors, tuples, pairs and boxes.
Generally, these collections provide the ability to store elements
that are possibly repeating
and operate on them perhaps by direct access or via iteration.

% - set
The second category is \emph{sets}.
Thus, collections that do not maintain repeated elements
and only store a single occurrence based on some equivalence criterion.

% - map
% - multi-map
% - bidirectional map
The third category is \emph{maps}, which maintain a mapping from keys to values.
We put bags, i.e., multi-sets, in this category as they map keys to a number of occurrences.
Languages such as Racket allow polymorphism between indexed sequences and maps (the key being the index).
%\bd{not clear, be more direct: In Racket sequences can be seen as a special case of maps.}\sm{hmmm, but this is saying something different. What I say is they have the same interface. you say lists are a special case. Think what you say is too specific and not generally true (Racket needs the list to be a list of explicit pairs, while a vector is directly a \code{dictionary}).}

% - stack
% - queue
% - deque
% - priority queues
%   - heap
% - ring
The fourth category is \emph{stacks and queues}.
These collections store elements
and restrict the access in a way
that facilitates the efficient implementation of certain use cases.
We include here deques, priority queues or heaps, and rings.

% - matrix
% - table 
The fifth category is \emph{composed collections}.
These are collections that could be built by combining multiple collections.
We include here for instance matrices, which are two-dimensional arrays,
and tables, which are two-dimensional maps.
Again, these two could be considered of the same class
if indexing with integers is considered an associative access.

% - range/slice
% - range map/set
The six category is \emph{ranged collections},
which are rare and appear for instance in form of range maps or sets.
% SM: I agree, they are not collection types, they are potential iterations
%     should not be named here, but are needed later
% However, we include here the ranges or slices as well,
% which are available in some languages
% and correspond to a reified potential iteration.
%\bd{Why potential?}\sm{because they still need to be applied. It's a specification for where to iterate, I'd say. You got a better word?}

\subsection{Language Style}
\label{sec:language-style}

The second category with a major influence on the collection design
is the language for which the library is designed.

% - language style
%   - object-oriented, procedural, functional, ...
The \emph{language style} in terms of being procedural, object-oriented,
or functional leads to different designs in shape and structure of collections
as well as the provided sets of operations on them and the operation naming.

The language's stance on \emph{typing} and its support for type parameters
shapes libraries in various ways.
% primitive maps/sets, ...
%   - primitive as keys or values
%  - bit sets
In dynamically-typed languages,
we see the need for explicit support of collections for primitive types, \eg,
to store numeric data efficiently.
This includes sequences for numeric elements (\eg \code{Int32Array} in ECMAScript)
or primitive maps or sets (\eg \code{IntMap in Scala}).
%      - templates
Typed languages often use some form of generics, type parameters, or templates,
which help to reduce a proliferation of collections for specific data types.
%\bd{and imho make the API far more complex}\sm{? not sure what you mean?
%You're saying Generics make APIs more complex? because of co/contra variance and stuff? sure, but typed languages need them. You want to add anything here?
%Or is this a point that's useful later: generics are complicated/distracting because X, and thus, it seems that dynamically typed languages might have an edge for exploratory programming?} => yeah, discussed later

In addition to typing, the \emph{reuse} mechanisms offered by a language have
an important impact on library structure.
For example, single inheritance can lead to designs with undesirable
properties as seen in the Smalltalk-80 collection library\citep{Cook:1992:ISS}.
While some of these issue can be worked around,
other reuse mechanisms such as traits,
might result in designs that have benefits\citep{Black:2003:ATS}.
% -> Smalltalk example \citep{Cook:1992:ISS}
%   -> if you only got single inheritance, only mechanism of reuse
%      that does not need composition (which might introduce other issues,
%      for instance performance overhead in interpreted languages)
%   -> subclassing not always ideal
%   -> some things are just not subclasses
%     -> deleting methods
%     -> providing other functionality via same name
%     -> structuring requires much care

In some case, languages evolved to facilitate
desired collection library designs\citep{Chakravarty:2005:ATC,Garcia:2007}.
In other cases,
the library needed to evolve
and use the available language mechanisms more effectively
to improve maintainability and code reuse\citep{Odersky:2009}.
% as for instance in the case of Scala



\subsection{Properties}
\label{sec:col-properties}

% In addition to the basic operations and properties\bd{Was not defined before, drop the sentence?} of collections,
% they can also vary in additional properties.
As noted in \cref{sec:col-types},
it is not always clear whether the properties of collections are orthogonal
to the collection type,
but they seem generally useful to be discussed separately.
% The identified properties are not completely independent
% of each other either.

\paragraph{Basic Properties}

% - fixed size/variable
For some of the collection types,
variants exist that have a \emph{fixed or variable size}.
For instance, sequences can be vectors with a variable size,
or arrays with a fixed size.
Similarly, queues might use a variable size implementation or a fixed sized to
enforce a bound on the upper queue length.

For many collection types,
there are variants that are \emph{ordered or unordered}.
Lists or other sequences commonly maintain insertion order,
which can be equally beneficial for maps, sets, and other collection types.

% - sorted (absolute, opt-in)
In addition to ordering, collections can \emph{sort elements}.
Some collections such as tree-based collections maintain a sorted order at all times and
provide operations taking advantage of this property.
Other collections might provide an operation to sort elements on demand.

\paragraph{Mutability}

% - mutability (mutable, immutable, read-only wrappers)
%  - absolute vs opt-in
% - persistence (persistent data structures, just an implementation technique for immutable collections? or does it have a design impact? probably, because of performance aspects)
% - copy on write

Collections can differ in their mutability
and be available in \emph{mutable} and \emph{immutable} versions.
Some libraries additionally provide \emph{read-only views} in form of wrappers.

Some immutable collections are implemented as \emph{persistent} data structures,
which use structural sharing to avoid high memory overhead when producing
a new version of a large collection with only minimal changes.

Special-purpose variations include further
\emph{copy-on-write} data structures
such as Java's \code{CopyOnWriteArrayList},
which can be used to isolate multiple entities
and enable mutability.
%while minimizing memory usage by employing structural sharing. % BD: no, CopyOnWriteArrayList does not use structural sharing


\paragraph{Multi-Threading Support}

% - concurrent (various different use cases for same collections)
% - parallel (for bulk operations, can also be realized via streams)
% - synchronized (just thread-safe wrappers)

To support multi-threaded applications, 
libraries can include various collection types.
The simplest solution to ensure correctness is
to provide \emph{synchronization wrappers} as done by Java and C\#.
However, this approach is rarely efficient
and often lacks support for performing multiple operations safely together.
% \bd{also iterators are typically not synchronized as they would hold the lock too long, at least in Java}
These problems are typically addressed
by specialized \emph{concurrent} collections,
which are optimized for specific use cases,
leading to a proliferation of collection types.
For instance a queue for a single producer but multiple consumers
can often be implemented
more efficiently than a queue for multiple producers.

For efficient bulk operations,
languages such as Scala provide \emph{parallel} collections,
which execute operations in parallel.
Similar to sorting, where some collections do it intrinsically,
parallel execution is often provided via operations
external to the collection (cf. \cref{sec:operations}).

\paragraph{Other Properties}

% - weak
\emph{Weak} collections are commonly offered to build caches
and other data structures that interact well with garbage collection
by enabling reclamation of not otherwise referenced objects.

% - lazy vs strict
Languages such as Haskell offer the distinction between \emph{lazy and strict}
collections to provide control over when operations are executed.
However, this distinction is not exclusive to lazy languages.
In conjunction with iteration,
other languages can also offer lazy execution.

% - identity-specific collections
%   - might be an optimization
%   - can generally be realized by parametrizable operations for example for comparisons or hashing

Finally, we found sets and maps
that use \emph{identity} as main distinguishing criterion.
Presumably, these collections are optimizations
because Java, Smalltalk, and Dart would allow to construct
maps that can be parameterized with appropriate operations
for comparison and hashing by identity.

\subsection{Operation Design}
\label{sec:operations}

% - basic operations
The design of collection operations depends
on the language style (cf. \cref{sec:language-style}).
The style influences naming, which operations are offered,
how bulk operations are realized, or errors are handled.
To give just one example, in Smalltalk it is common to pass closures as arguments
to operations that might fail to provide the failure handling code directly.
In other languages, return codes or exceptions indicate failure
and are handled externally to the collection.

% - sorting
There are other previously mentioned aspects
that influence the offered operations including immutability, persistence,
sorting, parallel bulk operations, laziness, iteration in general,
and possibly properties that are realized as some form of opt-in mechanism,
which may include immutability and read-only views.

% - polymorphism
%   - compatibility of collections
%     - maps as lists (iteration), lists as maps (int->T maps)
%     - immutable/mutable...
%     - use of wrappers?

One important aspect of designing the interfaces of collections is the intended
degree of polymorphism,
\ie, whether collections should offer the same interfaces.
To facilitate code reuse, one might want to design collections
with different properties such as being mutable or immutable
so that they can be used mostly interchangeably.
One way of doing this is by using decorators or wrappers around collections
that add the desired properties, \eg, read-only views or basic synchronization in Java.
Other options to consider are whether maps should be iterable
in the same way as sequences, or whether sequences can be treated as maps.

%- bulk operation
%  - order guarantees (everything modeled as lists)
%  - processing (sequential, parallel, lazy)
%  - slices
%  - internal/external iteration
%    - streams
%    - queries (linq)
%    - navigation (navigable Java)

Iteration or more general collection traversal is an important design point.
The basic properties ordering and sorting need to be taken into account.
Furthermore, iteration operations need to consider whether processing is
to be done sequentially, in parallel, or lazily.
Languages with slices or ranges can use these as interface
to define how to iterate.
Finally, other concepts such as internal vs external iteration, streams,
and language-integrated query (LINQ)
further influence the set of offered operations.

\subsection{Algorithms, Data Structures, and Implementation Choices}
\label{sec:impl-choices}

The final set of design dimensions are implementation choices,
which include the selection of a specific algorithm or data structure
to realize a collection.

Literature describes a large variety of special-purpose
data structures\citep{Pugh:1998:SkipList,Hinze:2006:Finger,Brodal:2013:PQ,Steindorfer:2015:OHM}, especially for concurrent applications\citep{Hendler:2004:SLS,1377094,1146165,InsertionTreePhasers,Prokopec:2018:CCL}.
However, there seem to be a few favorites that are recurring.
For
% - trees
% - tries, splay trees
% - skip lists
% - singly/doubly linked lists
trees we saw for instance red-black trees, tries, and splay trees,
for lists singly and doubly-linked ones, array-based, and skip lists,
% - specialization for stable, static, small vectors/lists
possibly with specializations for small or rarely changing lists.
%
% - specializations for small dicts
The concrete algorithms for hash tables are not usually specified
in the documentation.

% - wrappers for properties
Another important design dimension mentioned before is
how the various properties of collections are represented.
Some libraries provide separate classes for each possible type and property,
while others realize the desired properties with decorators,
\ie, wrapper constructs.

\section{Collection Usage}
\label{sec:usage}

As seen in the previous section,
collection libraries differ widely
in the number of collection types they provide
and the properties these collections can offer.
Especially Java provides a multitude of different collection types and still,
the wider community felt the need to provide and maintain libraries
for additional collections.
One important question to guide the design could therefore be:
which collection types are widely used and are likely going to be needed
for exploratory programming tasks?

To answer the question of which collection types are widely used,
\citet{Costa:2017:ESU} studied a GitHub corpus of Java projects\citep{6624029}.
They found that most instantiation sites for collections
create \code{ArrayList} objects.
From all sites analyzed, 47\% used the standard Java \code{ArrayList}.
Overall, about 56\% used some kind of list.
Maps where used by about 28\%,
where the great majority uses Java's \code{HashMap},
which results in a total of about 23\% of all allocations.
About 15\% all instantiation sites were for some set type.
Again, the large majority was for Java's \code{HashSet}
with about 10\% of all allocations.

The only other study on collection usage we are aware of
was included in work by \citet[sec. 9.2]{Bergel:2018}.
They observed that \code{OrderedCollection} (similar to \code{ArrayList})
and \code{Dictionary} (a map) are the most frequently used collections
in some larger Pharo Smalltalk projects.
While the study is less comprehensive than the Java one,
it confirms the general trend.
It also considers Smalltalk arrays
% \bd{What arrays? OrderedCollection or built-in Smalltalk arrays? Or primitive arrays?}
and finds that they are used slightly more often than \code{Dictionary}.

\section{A Collection Design for Exploratory Programming}

% key goals to facilitate exploratory programming:
%  - focus on problem domain
%  - avoid unnecessary decisions
%  - environment needs to be able to provide feedback
%    (errors, tooling, documentation)
%  - robustness, and perhaps even resilience
%  (not necessarily in the JS weak language/too many implicit conversions sense)

As discussed in \cref{sec:exploratory}, to facilitate exploratory programming
a collection library needs to help programmers to
1) focus on the problem domain
2) avoid unnecessary decisions
and 3) enable the environment to provide feedback in form of
\eg, errors, hints, tooling, and documentation.
To us, this means we either want to completely avoid a choice
for or against a specific collection type or property,
or postpone it as far as possible.
At the same time, when we made certain choices,
we want them to be reflected by the environment.
Thus, independently of how these choices are expressed in code,
the environment needs to recognize them to provide us maximal support.
Furthermore, we consider performance in this context a secondary concern.
While important for many applications,
we assume it is rarely the primary concern for exploratory programming.
Consequently, we prefer solutions that can provide perhaps 80\%
of a special purpose solution without exposing it to programmers. 

The remainder of this section first discusses the design dimensions
identified in \cref{sec:dimensions}
to propose choices that fit our vision for an exploratory programming setting.
Afterwards, we discuss the resulting overall design,
possible criticism, and tradeoffs. 

\subsection{Identifying a Point in the Design Space}

\paragraph{Types of Collections}

The first and perhaps most important choice seems to be the selection of the
desired set of collection types.
In \cref{sec:col-types}, we identified six groups.
However, considering the usage in actual applications (cf. \cref{sec:usage}),
only sequences, sets, and maps seem to be widely used.
To avoid unnecessary decisions,
we propose to use only a minimal set of collection types
based on the most widely used ones,
and to provide relevant functionality as part of these collections.
Furthermore, we suggest to design collection properties
in a way that one can easily opt into properties or opt out from them.
However, this should be designed together with tool support
to avoid losing relevant feedback from the environment.
For instance, if a list is used as a stack,
the environment should pick up on it,
and adapt code completion accordingly.
% \bd{What kind of feedback? Still unclear to me.}
% \sm{unclear, how?
% feedback in form of errors, hints, tooling, documentation. we just said that in the into to sec. 6, no?}
% \bd{I'd love an concrete example of feedback, because I don't know what kind of feedback/how smart it is.}
% SM: added example

It can be debated whether to include sets or not.
Sets can be easily emulated with maps
% \bd{(albeit with some memory overhead)},
% SM: we say we don't care, 80% is sufficient,
%     so, I don't think this needs to be included here
 or with set operations on sequences.
% \bd{but inefficient or easy to break the uniqueness invariant then, no?}.
% \bd{Need to clarify if it's just some extra oeprations like addUnique (but then normal add breaks uniqueness) or Ruby-like, which allows set operations on sequences by using a set internally basically, but then no efficient way to mutate the set/add an element after that}
% SM: hope the change is clarifying enough
Since the use and semantics of sets is distinct enough from sequences and maps,
and the various possible designs of emulating sets have drawbacks,
we would % err on the side of slightly bloating the basic set of collections and
include them directly,
even though there are a number of languages that do not do so.

Similarly, one can argue that maps are merely lists of pairs
or that all sequences should be associative arrays.
We agree that it can be beneficial to threat them as being polymorphic,
and Lua is a great example that shows having only associative arrays
(cf. \cref{sec:lua53}) is practical.
However, we consider the usage of maps and sequences
as sufficiently distinct to warrant
the distinction between them. 

Thus, we propose to include \emph{sequences}, \emph{maps}, and \emph{sets}.
% \bd{What's a good use-case for sets? Seems like a map with an unused value to me.}
% SM: every query where you want a uniqe set of elements at the end
%     happens plenty of times when processing data

\paragraph{Language Style}

Generally, we consider the language style as a given from the host language
and thus, it is not part of this discussion.
However, aspects such as typing can have a major influence on the design.
For dynamic languages,
we observed the inclusion of specific collection types for primitive data.
Since this increases the number of explicit choices one has to consider,
we would argue that it is better to rely on optimizations
at the implementation level for use cases
where performance is the main driver (cf. \cref{sec:impl-techniques}).

% Example for complexity of types:
%  - scala, type signatures are very complex
%    -> documentation presents a simplified version to hide some of the complexity
For typed languages, there seems to be a high degree of exposed complexity
for users.
For example in Scala, the collection library is designed
so that operations on collections produce output collections
with the same type as the input collection\citep{Odersky:2009}.
This leads to an exposure of highly complex type signatures to the user.
Scala choses to mitigate this by including simplified type signatures
in its documentation.
Thus, we advice collection designers to consider this issue
and ensure that tooling and documentation hide such accidental complexity.

\paragraph{Properties}

Because of the various properties collections might want to support,
it seems best to decide on the most flexible default case
and additionally consider mechanisms to opt into or out from certain properties.

% basic properties:
% fixed/variable -> single abstraction sequence, should be initializable with desired size to facilitate both types of usages
A good example is whether to offer fixed or variable sized collections.
Variable sized ones seem to be the most flexible solution.
However, to facilitate the use case and optimizations for fixed-size collections,
it is useful to offer for instance constructors
that allow creating a collection with the desired size and default value.
% bounded queues are special purpose, and should be provided as need by external library
Special purpose collections such as bounded queues could then be provided
as external libraries.

% ordered vs. unordered
% all collections should maintain insertion order
% gives dertminism
\label{sec:insertion-ordering-choice}
Similarly, maintaining insertion order for all collections seems to be a choice
that guarantees deterministic behavior and thus is often preferable.
% except for concurrency of course, but we don't care about perf/compelxity here
Other orderings could be offered with operations or iteration constructs.
% sorting as opt-in, either a mode, or operations to request sorted collection
This also means that sorting is arguably something one wants to opt into,
for instance by requesting a collection to be sorted or using operations that
maintain sorting explicitly.

% chocie between mutable and immutable 
%% probably tightly bound to language style
%% only need one type
On the other hand, the choice between having mutable and immutable collections is likely tightly
bound to the language style.
In the interest of maintaining a minimal set of collections only,
deciding on either mutable or immutable seems to be preferable and avoid confusion and duplication.
% \bd{mutable is more flexible, isn't it? But it might expose some extra complexity to the user}
% SM: that's a complex debate, and I don't think this is easily argued.
%     not sure I even agree. good immutable collections look like 
%% forgo read-only wrappers and copy-on-write things to keep things minimal
Similarly, we would relegate read-only wrappers or copy-on-write collections
to external libraries.

%% thread-safety
\label{sec:design-thread-safety}
%% should be provided implicitly by the language (cf. )
Thread-safety is desirable for languages
that support sharing collections between multiple threads.
As discussed in \cref{sec:impl-techniques},
we think this can be provided implicitly without drawbacks.
However, to provide atomicity of the right granularity,
collections need high-level operations
such as \code{computeIfPresent} or \code{putIfAbsent},
which typically check some condition on the collection,
potentially perform a user-specified operation, and then modify the collection.


%% parallel operations should be provide in orthogonal way
To keep the set of collections minimal,
parallel execution of bulk operations is
best introduced by orthogonal means.
%%  internal or external parallel operations, possibly in form of streams
This could mean as part of operations for internal traversal
or mechanisms for external traversal, possibly using streams.

%% laziness
Whether to support strict or lazy operations seems
to be a question of language style
and the alternative seems to be a candidate for external libraries.

%% weakness
Weakly referencing collections have many important applications,
but remain special purpose, thus, should be part of an external library as well.

%% identity, opt in, configurable, for instance map should have sensible default
%%   probably with a hash operation, which can be replaced when desired
Identity-based maps and sets are ideally realized
by parameterizing the collection.
Ideally, it has defaults appropriate for the language,
which can be easily customized.

\paragraph{Operation Design}

% language dependent
For a large part,
we assume that language style and type dictate a certain operation style.
% operations that are parameterized with closures might help explorability
However, operations on collections might be especially easy to access
for instance with good code completion.
% for explorative programming, good support for internal iteration seem useful
% including complex queries
% being bound to the collection makes the operations easily available in code completion
% that's not to say that external iteration with loops or streams is less powerful. A choice should be inline with language preferences 
Thus, supporting a wide range of internal iteration operations seems useful
and can support complex queries.
Concepts such as loops or streams for external iteration
can still be beneficial, too.
We also argue that these operations are easier to discover
than operations hidden in some complex hierarchy
of special purpose collection classes.
Thus, we consider a small set of collection types
with a large number of operations
as a choice beneficial for exploratory programming.
% \bd{There could be an argument internal iteration is much simpler for implementing in your own collection, to integrate with the existing collection framework, but requires lambdas to be convenient. External iteration is also arguably ugly on the caller side for most usages. But maybe out of scope? IMHO streams are a new abstraction which is not needed.}
% SM: not sure this is true. and ugly is also a matter of style/perspective
%
% high degree of polymorphims between collections seems desirable 
% allows for quickly changing collection type
% or generalizing code
Furthermore, ensuring a high degree of polymorphism between collections
seems especially desirable in the exploratory stage,
because it allows switching between collections or generalizing code
without accidental complexity and technical issues distracting form the problem to be solved.

\paragraph{Algorithms, Data Structures, and Implementation Choices}

Having to pick any specific algorithm or internal representation of a collection
in the exploratory programming stage seems to be solely a distraction.
While there can be important performance difference,
we would argue that it is better to forgo perfect performance
and instead expect the underlying implementation
to be \emph{sufficiently smart}.
As argued in \cref{sec:impl-techniques},
it seems feasible and practical to make this tradeoff.


\subsection{Discussion}

Based on the analysis above,
we argue that a collection library designed for exploratory programming
should have sequences, maps, and sets as basic abstractions.
Relevant properties and modes of operations for collections should be
realized by mechanisms that allow for an easy opt in,
without requiring additional collection types.
In many cases this likely means
that the basic collections have a large and versatile set of operations.
We assume this can be supported by tooling to provide the desired feedback
for instance as part of code completion.
% - might need ecosystem of collection library for special purpose
%  - but that's the case for most languages and seems small inconvenience
However, this also means that many specialized collections should be relegated
into external libraries.
Depending on the language ecosystem,
this hopefully implies only minor inconvenience
and is supported by packaging and dependency management systems.

% - Generalization vs. Specialization  
% - small set of generalized collection types 
% - or large set of specialized types
% - is small and versatile bad design because it violates the 
%   `one thing does   one thing good premise'
%   - are those classes blobs? 
One could now argue that having many different types of operations
on the same collection type violates the good design practice
of having one thing do one thing alone and do it well.
One might even consider such large collection types as
an instance of \emph{the blob} anti-pattern.\citep{brown1998antipatterns}
% -> however, The Blob anti-pattern combines complex state and behavior
%    such collection design is not a direct instance of it, because
%    the contained data is usually still used for a single purpose and
%    it is merely that the collections themselves offer too much
%    functionality

% -> yes, it's an issue, the code is not clear about what kind of 
%    interactions one wants to allow on the collection
The strongest argument we see is
that code interacting with the collection is not explicit about
the desired usage.
% \bd{disagreed, see below and let's not shoot ourselves}
For instance, a sequence can be easily used as a stack, queue, deque, or list.
% \bd{Well, what if I use it as a deque?}
% SM: what's the point? not sure how this is related to anything?
%     I added deque to the list of examples.
%      - some people argue that programs are better understood if these things are explicit: \citep{PeytonJones:1996:BTC}
%        -> """The type of the object does not specify its invariant (\eg in a set there are no duplicates) and its expected operations (\eg lookup in a infinite map). The lack of these invariants makes the program harder to understand, harder to prove properties about, and harder to maintain."""
%        -> generic data structures (lists in case of Haskell) might not be optimal
Other arguments, for instance by \citet{PeytonJones:1996:BTC}
include that such generic types and the lack of specific invariants
make it harder to understand programs, harder to prove properties about them,
and harder to maintain them.
%
%However, one rarely wants to switch between different usages
%on the same collection instance.
%Mixing up the relevant operations is thus likely a bug. BD: where is this going?
However, in our experience, versatile collections
such as JavaScript or Ruby \code{Array}s are in most cases
used with only a few different operations
that clearly indicate a specific ``type''.
For instance, when \code{push} and \code{pop} operations are used on a sequence,
it is very clear it is meant to be used as a stack.
Furthermore, we argue that advanced type inference and run-time feedback
can enable development environments to detect such patterns
and provide useful feedback to programmers.
%and other operations are infrequently used on the same collection. BD: already mentioned above
% For instance, a collection on which the
% are used is a stack and a collection on which \code{append} is used a vector.
% When iterating, the specific type for a sequence does not matter in most cases,
% we just iterate all elements of the sequence, in the order they were added (cf. \cref{sec:insertion-ordering-choice}).
%
%For languages such as Java, the idiomatic advise is
%to disregard implementation strategies and performance differences
%in most code to facilitate reuse.
%Thus, one rarely sees the use of \code{ArrayList} or \code{HashMap}
%in operation signatures.
%Instead, the \code{List} and \code{Map} interfaces are used.
For languages such as Java, it is idiomatic to use the \code{List}, \code{Map}, or \code{Set} interfaces instead of concrete classes such as \code{ArrayList} or \code{HashMap} to facilitate reuse.
This illustrates that in many cases the specific type
is less desirable than argued by \citet{PeytonJones:1996:BTC}.
Furthermore, these three interfaces correspond to the collection types we propose to include.

Another argument supporting our choice is that it is desirable to separate the
optimization concerns from the algorithms.
It is a common goal for high-performance computing languages, such as the
partitioned global address space languages\citep{PGASSurvey},
to make concerns such as the memory layout and access patterns for matrixes and arrays secondary issues,
which can be handled as annotations or properties of data structures.
The goal here is to allow domain experts to build algorithms,
which then later can be optimized by performance experts that ideally only need
to add some annotations to ensure an efficient execution.


% or implementation is of little concern and instead the general collection type or interface is clear enough for the usages of the collection.

% -> set/map: implemented as tree or hash table?
% -> linked list or array list, or linked segments?
% -> can't make a right choice without knowing exactly what
%    run time load is going to be

More generally, we believe that performance-driven choices are 
% With a minimal set of collection types,
% it is also not possible to directly select an implementation strategy.
% Should a map be realized by a tree or hash table,
% or should a list be linked to allow fast insertion at arbitrary positions?
% We argue that these choices are
rarely possible in an informed manner during
exploratory programming.
Having not yet fully understood the problem,
one would likely mispredict the distribution of operations at run time.
Therefore, specialized classes are unlikely to be beneficial.

% -> complexity of implementation is a real issue (concurrency issues,
%    strategies, JIT DS...)
Another argument against versatile collections is
that their implementation is much more complex
and removes developers another step from the machine
and understanding performance tradeoffs.
From our perspective, moving the complexity into the runtime is beneficial,
because many users can leverage such optimizations implicitly.
At run time, optimization can become possible
without requiring programmer input,
as discussed in the following section.
For such optimizations, a runtime needs to make however many assumptions,
which likely reduces performance predictability.
Here we advocate for better tools.
Ideally, the environment can utilize the knowledge about run-time optimizations
to provide users with information on performance issues,
which can be considered by programmers
at a point when they start to care about performance.

% - drawback of too specialized classes:
%   - can become inflexible
%     -> need conversion or adapters to perform certain operations
%     -> large class hierarchies, hard to chose one, might not even be
%        clear what options are available, or appropriate for problem


\section{Techniques for Efficient Implementations}
\label{sec:impl-techniques}

While we consider performance a secondary concern for exploratory programming,
good performance is still essential to make a collection design practical.

% How to realize all this with same efficiency as when using special purpose
% collections?
% - probably not getting there 100\%, but 90\% or even 80\% are sufficient
%   when it improves developer productivity (which still has to be proven of course)
With the proposed design, it is likely not possible to achieve 100\%
of the performance that specialized collections can provide
for specific use cases.
However, trading some performance for more programmer productivity
seems beneficial.

% General Solution: adaptive data structures
%   - chose specific implementation/algorithm/data structure
%      -> \citet{PeytonJones:1996:BTC} already talks about 2.3 Adaptive representations
%      A probabilistic approach to the problem of automatic selection of data representations \citep{Chuang:1996:PAP}
%       -> markov processes
The main technique enabling good performance,
even when specialized collection types are not exposed,
are to use automatic data structure selection or adaptive data structures.
\citet[sec. 2.3]{PeytonJones:1996:BTC} and \citet{Chuang:1996:PAP}
already contemplated their use.
% more recently,   -> JIT Data Structures
More recently, \citet{DeWael:15:JitData} experimented
with so-called just-in-time data structures,
which allows a data structure to specialize
based on observed usage patterns.
Such techniques are used successfully
for collections in dynamic languages.
%  -> strategies (seq, par)
%   - Storage strategies for collections in dynamically typed languages
For example, storage strategies\citep{Bolz:2013:SSC,Clifford:2015:MMD} 
ensure that homogeneous collections use efficient in-memory representation
avoiding boxing without static types. 
% -> statically typed languages 
%   - compiler for static languages can do certain optimizations ahead of time:
%     - compiler-level specialization as with miniboxing \citep{Ureche:2013:MIS}
%     - C++ templates (expanding ones), eager specialization
Statically-typed languages can use mechanisms such as
C++ templates to specialize code at compile time.
% and even on top of just-in-time compiling runtimes,
% techniques such as miniboxing allow efficient representation by exploiting
% compile-time information\citep{Ureche:2013:MIS}.

\citet{Xu2013} and \citet{Costa:2018:CS} go beyond simply avoiding boxing.
They show that collections can be adapted further to take concrete usage
in terms of used operations into account.
For example, if a \code{contains()} operation is used frequently
on large lists, it can be beneficial to change its implementation to include
a hash table to speed up the lookup.
% for immutable collections
%   - Tobias Pape's paper, for functional data structures
For languages that prefer immutable collections,
there is similar work for instance by \citet{Pape:2017:VC},
which improves the memory representation of immutable data structures.
% \citet{Steindorfer:2015:OHM}
% add M. Steindorfer as reference for complex immutable/specialized data structures
% Note: doesn't fit the topic, because it isn't adaptive

% -> thread safe objects
%    -> concurrency strategy paper

As mentioned in \cref{sec:design-thread-safety},
thread-safety is ideally provided implicitly
without requiring programmer intervention.
Furthermore, there should not be any cost associated with such thread-safety
if a collection is used only by a single thread.
We think this is possible by combining our techniques
for thread-safe object representations\citep{Daloze:2016:TSO}
for dynamic languages with storage strategies. % BD: Spoiler alert!

% \bd{All quite abstract for sby not knowing storage strategies and friends, maybe give a concrete example?}
% SM: I don't want to make the section much longer
%%    Ideally, it fits on half a page

To gain the last bits of performance,
one might want to consider the needs of specialized collections,
% while designing the generic ones,
for instance by ensuring that operations conform to a common interface.
% It seems plausible that the operations are polymorphic.
In such cases,
the instantiation of a generic collection could simply be replaced
with a specialized one, possibly from an external library.
This might even be facilitated by tooling
which determines that a specific sequence allocation results in objects being
always used as a queue.
At this point, a compiler could select a queue implementation.
In gradually-typed languages,
this could be further supported by adding types
where performance becomes relevant,
which may facilitate the selection of a more efficient implementation
when only a subset of operations is used.
% In dynamic runtimes, such decisions could even be taken optimistically
% and reversed if the assumption turned out to be violated.
% To ensure learning, dynamic runtimes typically use allocation-site feedback\citep{Clifford:2015:MMD}.

% \bd{Small summary here to summarize all these hardcore details? We can have good perf for small/versatile collections thanks to these many technicques and many implementations use them.}
% SM: that's for the conclusion

% \begin{note}
%
% How to design so that specialized collections remain possible?
% And are easily adopted?
%  -> ensure subset of collection APIs are polymorphic
%    -> ideally, one just changes the constructor, or adds a conversion
%    -> idea would be that this gives the last 10-20\% of performance when needed
%    -> leave door open for improving performance by restricting flexibility
%  -> gradual typing based implementation selection?
% \end{note}

%% TODO:
% what is required in terms of efficiency?
% compilation-time feedback - needs to be fast to compile
% run-time performance - needs to be fast to execute
% 
% \citep{Rein:2016:LLP} should look a little more into this one for terminology 


\section{Related Work}

While collection design seems to be an integral aspect of language design,
we are not aware of any systematic treatment.
While there is some work on addressing certain 
issues\citep{Cook:1992:ISS,Black:2003:ATS,Chakravarty:2005:ATC,Garcia:2007},
there does not seem to be any general discussion of design tradeoffs.
However, \citet{Odersky:2009} describe their experience
redesigning the collection library in Scala.
Their focus is mostly on how they achieved an implementation and design
that is more principled, structured, and avoids code duplication
to avoid bit rot during future maintenance.
% The library itself is large with many specialized classes (cf. \cref{sec:scala-col}).
Also somewhat related, \citet{Matthes:2000:BT} investigate the question of how to design \emph{bulk types}, i.e., collection libraries, on the intersection to database systems and database programming languages.
They discuss the benefits and drawbacks of builtin or library-based designs and favor library-based designs for their extensibility.
For languages, we argue for a small set of versatile builtin collections
that allows extensions from external libraries.
% \sm{discussion in paper context: assume we have good knowledge from the various languages and libraries what is necessary, assume that extensibility is not a problem either, because the languages could be dynamic and therefore lent itself naturally to simply changing the collection implementation if required.
% Though, there might be limitations to what can be changed without interfering with optimizations such as strategies\todoref{}.}
% Live Data Structure Programming \citep{Oka:2017:LDS}
% - visualization
% - generic data structures

\section{Conclusion}

This paper informally reviews collection libraries of \LangCnt languages to identify
design dimensions and concerns that impact programming experience.
Based on the identified dimensions
and a brief literature review of collection usage studies,
we argue that a small set of collections with versatile operations
is beneficial for exploratory programming.
%Specifically, we propose to only offer sequences, maps, and sets.
%\bd{and only one user-visible type for each of those}
Specifically, we propose to only offer three collections, a sequence, a map, and a set.
We further argue that these collections can be implemented efficiently
with modern run-time techniques.

From our perspective, this design facilitates exploratory programming,
because it avoids many typical implementation decisions or relegates them to the runtime.
Specifically, it avoids deciding upfront on a specific collection type
or data structure.
Consequently, adapting the usage of a collection,
\eg, from a vector to a stack becomes trivial
and does not interrupt the process of understanding the domain problem.
% \bd{
% Switching to another usage with a versatile collection (e.g., using it as a vector instead of a stack) becomes trivial,
% instead of having to carefully review each usage.
% }
Having a large set of operations on a small set of collections also
provides better discoverability,
because specialized operations
are not lost in complex hierarchies of collection types.
Thus, the collection library is likely simpler and more convenient to use.

The drawback is that such collections
add complexity to language implementations,
which must provide complex optimizations
to achieve a performance similar to specialized collections.
However, many techniques already exist to optimize these collections
and increasing language implementation complexity for improved productivity
seems to be an acceptable tradeoff.

% We also observed and documented how varied is the collection design landscape in many languages.
%
% C has the most minimal collection library, and Ruby has the best collection design :D

% While I have convinced myself
% that I do prefer the programming style offered
% by a small and versatile collections library,
% I cannot shake the feeling
% that this is a post hoc justification
% for the complexity we add to VMs.

Future work should chart the design space for collection libraries more 
thoroughly and completely.
It would be useful to develop a common taxonomy for all related concepts
because there is rarely any agreement on naming or semantics between different
libraries.
%A taxonomy could be developed to clearly compare the collections types
%that most languages name differently.
This is only a first snapshot of a small set of languages and libraries.
For example, the ecosystems of Java and  C/C++
offer many other collection libraries,
with various tradeoffs.
Other types of languages, such as array programming,
scientific computations, or large-scale parallelism come with their own
requirements, which have not been considered.
In this survey we also focused only on the types of collections
without investigating operations on them in any detail,
which should be done in a more detailed study.

Further work should also investigate the human component and determine whether
our design is indeed beneficial for productivity.
Similarly, work on improved collection implementations,
a better understanding of performance tradeoffs,
as well as support for feedback from development environments is desirable. 
To provide appropriate feedback,
code completion should for instance know how operations relate to each other.
Similarly, run-time visualization and presentation of collections
is essential to understand program execution.
Thus, ways of focusing presentation or customizing it should be considered.

Finally, one might argue that
our proposed simplification of collection libraries
brings them back to the essential set of features and collection types
and that it could be widely beneficial beyond exploratory programming.
We think this is an interesting and promising thought,
which we would like to see explored in the future to make collection libraries
simpler, more discoverable, and easier to use for mundane tasks.

%
% \begin{note}
%
%   - future work
%     -complete taxonomy
%     -more complete survey
%     -> other languages, language types
%     -> other libraries that complement standard libraries
% \end{note}



%% ATTIC, Notes on Things Considered, but not included
%% ===================================================

%% Streams
%%
%% finite, or infinite sequence of values
%% aren't collections, just one way to express iteration/transformation

\begin{acks}
We would like to thank the workshop participants for their insightful comments
and suggestions to improve the paper.
\end{acks}


{\balance
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
}

\end{document}
