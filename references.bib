@inproceedings{Bolz:2013:SSC,
  acmid = {2509531},
  added-at = {2015-03-20T11:44:58.000+0100},
  author = {Bolz, Carl Friedrich and Diekmann, Lukas and Tratt, Laurence},
  biburl = {https://www.bibsonomy.org/bibtex/28f40c457da1215fa2253f4669d8f2141/gron},
  booktitle = {Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages \& Applications},
  description = {Storage strategies for collections in dynamically typed languages},
  doi = {10.1145/2509136.2509531},
  interhash = {79dbf78284a25256837af40293f3969b},
  intrahash = {8f40c457da1215fa2253f4669d8f2141},
  isbn = {978-1-4503-2374-1},
  keywords = {Arrays Collections Lists Optimization Pattern Performance Strategy VM},
  location = {Indianapolis, Indiana, USA},
  numpages = {16},
  pages = {167--182},
  publisher = {ACM},
  series = {OOPSLA'13},
  timestamp = {2017-11-09T15:49:40.000+0100},
  title = {Storage Strategies for Collections in Dynamically Typed Languages},
  year = 2013
}

@book{brown1998antipatterns,
  added-at = {2018-01-23T00:54:34.000+0100},
  address = {New York},
  author = {Brown, William J. and Malveau, Raphael C. and McCormick, Hays W. and Mowbray, Thomas J.},
  biburl = {https://www.bibsonomy.org/bibtex/2c00f52137e005d8673ec2edfe88d77d5/gron},
  description = {AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis: William J. Brown, Raphael C. Malveau, Hays W. "Skip" McCormick, Thomas J. Mowbray: 9780471197133: Amazon.com: Books},
  interhash = {789701a128664c7aaefcf8a00a2567f6},
  intrahash = {c00f52137e005d8673ec2edfe88d77d5},
  isbn = {9780471197133},
  keywords = {AntiPatterns Engineering Patterns Software TheBlob},
  publisher = {John Wiley and Sons},
  refid = {716881111},
  timestamp = {2018-01-23T00:54:34.000+0100},
  title = {AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis},
  year = 1998
}

@inproceedings{Costa:2017:ESU,
  abstract = {Collection data structures have a major impact on the performance of applications, especially in languages such as Java, C#, or C++. This requires a developer to select an appropriate collection from a large set of possibilities, including different abstractions (e.g. list, map, set, queue), and multiple implementations. In Java, the default implementation of collections is provided by the standard Java Collection Framework (JCF). However, there exist a large variety of less known third-party collection libraries which can provide substantial performance benefits with minimal code changes. In this paper, we first study the popularity and usage patterns of collection implementations by mining a code corpus comprised of 10,986 Java projects. We use the results to evaluate and compare the performance of the six most popular alternative collection libraries in a large variety of scenarios. We found that for almost every scenario and JCF collection type there is an alternative implementation that greatly decreases memory consumption while offering comparable or even better execution time. Memory savings range from 60% to 88% thanks to reduced overhead and some operations execute 1.5x to 50x faster. We present our results as a comprehensive guideline to help developers in identifying the scenarios in which an alternative implementation can provide a substantial performance improvement. Finally, we discuss how some coding patterns result in substantial performance differences of collections.},
  acmid = {3030221},
  added-at = {2018-01-15T17:31:16.000+0100},
  address = {New York, NY, USA},
  author = {Costa, Diego and Andrzejak, Artur and Seboek, Janos and Lo, David},
  biburl = {https://www.bibsonomy.org/bibtex/2b41a078eda7211c5a0225eb1c7cbfeb0/gron},
  booktitle = {Proceedings of the 8th ACM/SPEC on International Conference on Performance Engineering},
  description = {Empirical Study of Usage and Performance of Java Collections},
  doi = {10.1145/3030207.3030221},
  interhash = {d4ad4eeaa3bf151508506d442199f037},
  intrahash = {b41a078eda7211c5a0225eb1c7cbfeb0},
  isbn = {978-1-4503-4404-3},
  keywords = {ArrayList Collections DataStructures Java JustInTime Optimization Performance Survey Usage},
  location = {L'Aquila, Italy},
  numpages = {12},
  pages = {389--400},
  publisher = {ACM},
  series = {ICPE'17},
  timestamp = {2018-01-15T17:31:16.000+0100},
  title = {{Empirical Study of Usage and Performance of Java Collections}},
  year = 2017
}

@article{Bergel:2018,
  abstract = {Expandable collections are collections whose size may vary as elements are added and removed. Hash maps and ordered collections are popular expandable collections. Expandable collection classes offer an easy-to-use API, however this apparent simplicity is accompanied by a significant amount of wasted resources. We describe some improvements of the collection library to reduce the amount of waste associated with collection expansions. We have designed two new collection libraries for the Pharo programming language that exhibit better resource management than the standard library. We improved the Pharo collection library using two complementary perspectives. First, across a basket of 5 applications, our optimized collection library significantly reduces the memory footprint of the collections: (i) the amount of intermediary internal array storage by 73%, (ii) the number of allocated bytes by 67% and (iii) the number of unused bytes by 72%. This reduction of memory is accompanied by a speedup of about 3% for most of our benchmarks. Second, we looked for an alternative to the classical expandable collection. The Lua programming language offers a unique abstract data type called table. We designed, implemented, and introduced this data type in the Pharo programming language and we ran a number of micro and macro-benchmarks. Overall, replacing the standard Pharo collection library by one inspired on Lua's table data type results in an execution speedup of up to 15% and a reduction of the memory consumption by up to 19%. We analyzed the collection implementations of Java, C#, Scala, and Ruby: these implementations largely behave like Pharo's, therefore with the same limitations. Our results are thus likely to benefit designers of future programming languages and collection libraries.},
  added-at = {2018-01-24T00:35:27.000+0100},
  author = {Bergel, Alexandre and Infante, Alejandro and Maass, Sergio and Alcocer, Juan Pablo Sandoval},
  biburl = {https://www.bibsonomy.org/bibtex/2d141399f43fc26c2c1acb99d1603b801/gron},
  description = {Reducing resource consumption of expandable collections: The Pharo case - ScienceDirect},
  doi = {10.1016/j.scico.2017.12.009},
  interhash = {555ccfacedaceaba41eec65699aaa0de},
  intrahash = {d141399f43fc26c2c1acb99d1603b801},
  issn = {0167-6423},
  journal = {Science of Computer Programming},
  keywords = {ArrayList Collections Lua OrderedCollection Smalltalk Survey Table},
  timestamp = {2018-01-24T00:35:27.000+0100},
  title = {Reducing Resource Consumption of Expandable Collections: The Pharo Case},
  year = 2018
}

@inproceedings{Odersky:2009,
  added-at = {2018-01-26T00:38:37.000+0100},
  address = {Dagstuhl, Germany},
  annote = {Keywords: Programming languages, scala, avoiding code duplication, higher-order kinds, type systems, polymorphism, collections library},
  author = {Odersky, Martin and Moors, Adriaan},
  biburl = {https://www.bibsonomy.org/bibtex/28e7d0424f0a66ab774a92ae61afc2d21/gron},
  booktitle = {IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science},
  doi = {10.4230/LIPIcs.FSTTCS.2009.2338},
  editor = {Kannan, Ravi and Kumar, K. Narayan},
  interhash = {627bf825bd5abd6c0411b594a26b6ced},
  intrahash = {8e7d0424f0a66ab774a92ae61afc2d21},
  isbn = {978-3-939897-13-2},
  issn = {1868-8969},
  keywords = {Collections Design ExperienceReport Scala},
  pages = {427--451},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  timestamp = {2018-01-26T00:38:37.000+0100},
  title = {{Fighting bit Rot with Types (Experience Report: Scala Collections)}},
  url = {http://drops.dagstuhl.de/opus/volltexte/2009/2338},
  urn = {urn:nbn:de:0030-drops-23386},
  volume = 4,
  year = 2009
}

@article{Garcia:2007,
  abstract = {AbstractMany modern programming languages support basic generics, sufficient to implement type-safe polymorphic containers. Some languages have moved beyond this basic support, and in doing so have enabled a broader, more powerful form of generic programming. This paper reports on a comprehensive comparison of facilities for generic programming in eight programming languages: C++, Standard ML, Objective Caml, Haskell, Eiffel, Java, C# (with its proposed generics extension), and Cecil. By implementing a substantial example in each of these languages, we illustrate how the basic roles of generic programming can be represented in each language. We also identify eight language properties that support this broader view of generic programming: support for multi-type concepts, multiple constraints on type parameters, convenient associated type access, constraints on associated types, retroactive modeling, type aliases, separate compilation of algorithms and data structures, and implicit argument type deduction for generic algorithms. We find that these features are necessary to avoid awkward designs, poor maintainability, and painfully verbose code. As languages increasingly support generics, it is important that language designers understand the features necessary to enable the effective use of generics and that their absence can cause difficulties for programmers.},
  added-at = {2018-01-28T17:20:18.000+0100},
  author = {Garcia, Ronald and Järvi, Jaakko and Lumsdaine, Andrew and Siek, Jeremy and Willcock, Jeremiah},
  biburl = {https://www.bibsonomy.org/bibtex/27813d47b79f3428c6610fe61146c2f80/gron},
  booktitle = {Journal of Functional Programming},
  description = {An extended comparative study of language support for generic programming | Journal of Functional Programming | Cambridge Core},
  doi = {10.1017/S0956796806006198},
  interhash = {89ce17b918331ea78647442a23d3cf96},
  intrahash = {7813d47b79f3428c6610fe61146c2f80},
  issn = {09567968},
  keywords = {Design GenericProgramming Generics Graphs Library Templates},
  number = 2,
  pages = {145--205},
  publisher = {Cambridge University Press},
  timestamp = {2018-01-28T17:20:18.000+0100},
  title = {An extended comparative study of language support for generic programming},
  url = {https://www.cambridge.org/core/article/an-extended-comparative-study-of-language-support-for-generic-programming/C97D5964ECC2E651EEF9A70BC50600A6},
  volume = 17,
  year = 2007
}

@inproceedings{Chakravarty:2005:ATC,
  acmid = {1040306},
  added-at = {2018-01-28T17:25:16.000+0100},
  author = {Chakravarty, Manuel M. T. and Keller, Gabriele and Peyton Jones, Simon L. and Marlow, Simon},
  biburl = {https://www.bibsonomy.org/bibtex/28abc0ad9ede1ff26e104870b16839fa8/gron},
  booktitle = {Proceedings of the 32nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  description = {Associated types with class},
  doi = {10.1145/1040305.1040306},
  interhash = {bcfe3819f9c4e8261e679bcaea7de4ee},
  intrahash = {8abc0ad9ede1ff26e104870b16839fa8},
  isbn = {1-58113-830-X},
  keywords = {Haskell LanguageDesign Polymorphism TypeClasses Types},
  location = {Long Beach, California, USA},
  numpages = {13},
  pages = {1--13},
  publisher = {ACM},
  series = {POPL'05},
  timestamp = {2018-01-28T17:25:16.000+0100},
  title = {{Associated Types with Class}},
  url = {http://simonmar.github.io/bib/papers/assoc.pdf},
  year = 2005
}

@inproceedings{Cook:1992:ISS,
  acmid = {141938},
  added-at = {2018-01-28T17:30:51.000+0100},
  author = {Cook, William R.},
  biburl = {https://www.bibsonomy.org/bibtex/251953149154e17f2016e9c55a67cf07d/gron},
  booktitle = {Conference Proceedings on Object-oriented Programming Systems, Languages, and Applications},
  doi = {10.1145/141936.141938},
  interhash = {fbf24e25c58a2656d46634d2bae86fc2},
  intrahash = {51953149154e17f2016e9c55a67cf07d},
  isbn = {0-201-53372-3},
  keywords = {Collections Hierarchy Inheritance LibraryDesign Reuse Smalltalk},
  location = {Vancouver, British Columbia, Canada},
  numpages = {15},
  pages = {1--15},
  publisher = {ACM},
  series = {OOPSLA'92},
  timestamp = {2018-01-28T17:30:51.000+0100},
  title = {{Interfaces and Specifications for the Smalltalk-80 Collection Classes}},
  year = 1992
}

@inproceedings{Black:2003:ATS,
  added-at = {2008-06-20T12:15:49.000+0200},
  author = {Black, Andrew P. and Sch\"{a}rli, Nathanael and Ducasse, St\'{e}phane},
  biburl = {https://www.bibsonomy.org/bibtex/29fd14266178cf60aea252e36fb322077/gron},
  booktitle = {Proceedings of the 18th Annual ACM SIGPLAN Conference on Object-oriented Programing, Systems, Languages, and Applications},
  description = {Traits},
  doi = {10.1145/949305.949311},
  file = {p47-black.pdf:Traits\\p47-black.pdf:PDF},
  interhash = {2252e080d93a9c1317fbe3272c2cba7f},
  intrahash = {9fd14266178cf60aea252e36fb322077},
  isbn = {1-58113-712-5},
  keywords = {SDSeminar Traits},
  location = {Anaheim, California, USA},
  pages = {47--64},
  publisher = {ACM},
  series = {OOPSLA'03},
  timestamp = {2018-01-28T17:39:50.000+0100},
  title = {{Applying Traits to the Smalltalk Collection Classes}},
  year = 2003
}

@inproceedings{PeytonJones:1996:BTC,
  abstract = {
Bulk types - such as lists, bags, ets, finite maps, and priority queues - are ubiquitous in programming. Yet many languages don't support them well, even though they have received a great deal of attention, especially from the database community. Haskell is currently among the culprits.

This paper has two aims: to identify some of the technical difficulties, and to attempt to address them using Haskell's constructor classes.},
  added-at = {2018-01-28T18:29:41.000+0100},
  author = {Peyton Jones, Simon L.},
  biburl = {https://www.bibsonomy.org/bibtex/264cd09eed7755794c01cf21eaaf182ab/gron},
  booktitle = {Proceedings of the Second Haskell Workshop},
  interhash = {fa9dac8421798fc3ce1d97b3d33f5e2d},
  intrahash = {64cd09eed7755794c01cf21eaaf182ab},
  keywords = {BulkTypes Collections Haskell Lists Maps},
  month = {September},
  timestamp = {2018-01-28T18:29:41.000+0100},
  title = {{Bulk types with class}},
  url = {https://www.microsoft.com/en-us/research/publication/bulk-types-with-class/},
  year = 1996
}

@inproceedings{Chuang:1996:PAP,
  acmid = {232648},
  added-at = {2018-01-28T18:52:44.000+0100},
  author = {Chuang, Tyng-Ruey and Hwang, Wen L.},
  biburl = {https://www.bibsonomy.org/bibtex/2cbcbae8045b0031bab533c438c0d68b0/gron},
  booktitle = {Proceedings of the First ACM SIGPLAN International Conference on Functional Programming},
  doi = {10.1145/232627.232648},
  interhash = {27c627e1760d23fd91eb621219cc5cce},
  intrahash = {cbcbae8045b0031bab533c438c0d68b0},
  isbn = {0-89791-770-7},
  keywords = {Collections DataStructures JIT Maps Online RunTime Selection},
  location = {Philadelphia, Pennsylvania, USA},
  numpages = {11},
  pages = {190--200},
  publisher = {ACM},
  series = {ICFP'96},
  timestamp = {2018-01-28T18:52:44.000+0100},
  title = {{A Probabilistic Approach to the Problem of Automatic Selection of Data Representations}},
  year = 1996
}

@inbook{Matthes:2000:BT,
  abstract = {Bulk structures play a central r{\^o}le in data-intensive application programming. The issues of bulk type definition and implementation as well as their integration into database programming languages are, therefore, key topics in current DBPL research.},
  added-at = {2018-01-28T20:23:03.000+0100},
  address = {Berlin, Heidelberg},
  author = {Matthes, Florian and Schmidt, Joachim W.},
  biburl = {https://www.bibsonomy.org/bibtex/2da8e43dba223861c028556c5bdec6fe7/gron},
  booktitle = {Fully Integrated Data Environments: Persistent Programming Languages, Object Stores, and Programming Environments},
  doi = {10.1007/978-3-642-59623-0_16},
  editor = {Atkinson, Malcolm P. and Welland, Ray},
  interhash = {820ad136d1f2b2785dc8a1b4b3e89fb1},
  intrahash = {da8e43dba223861c028556c5bdec6fe7},
  isbn = {978-3-642-59623-0},
  keywords = {Collections DataBases Framework LanguageDesign Library PositionPaper},
  pages = {257--261},
  publisher = {Springer},
  timestamp = {2018-01-28T20:23:03.000+0100},
  title = {Bulk Types: Built-in or Add-On?},
  year = 2000
}

@inproceedings{Ureche:2013:MIS,
  acmid = {2509537},
  added-at = {2016-10-20T17:56:24.000+0200},
  author = {Ureche, Vlad and Talau, Cristian and Odersky, Martin},
  biburl = {https://www.bibsonomy.org/bibtex/29eba89108968f5d77e613055a65e2a8e/gron},
  booktitle = {Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages \& Applications},
  description = {Miniboxing},
  doi = {10.1145/2509136.2509537},
  interhash = {53536f0efef54c196e60f2077e16088d},
  intrahash = {9eba89108968f5d77e613055a65e2a8e},
  isbn = {978-1-4503-2374-1},
  keywords = {Miniboxing Scala boxing compiler optimization transformation},
  location = {Indianapolis, Indiana, USA},
  numpages = {20},
  pages = {73--92},
  publisher = {ACM},
  series = {OOPSLA'13},
  timestamp = {2016-10-20T17:56:24.000+0200},
  title = {{Miniboxing: Improving the Speed to Code Size Tradeoff in Parametric Polymorphism Translations}},
  year = 2013
}

@inproceedings{Oka:2017:LDS,
  abstract = {When we write a program that manipulates data structures, we often draw and manipulate a visual image of the structures in our mind. In order to immediately connect those mental images with the data objects created by the program, we propose a live programming environment, called Kanon, specialized for data structure programming. It automatically executes a program being edited, and draws objects and their mutual references as a node-link diagram. In order to visualize information relevant to the programmer's concern, it offers two visualization modes based on the cursor position in the editor. It also offers two interactive mechanisms that relate elements in the program to elements on the diagram, and vice versa. The implementation includes a novel technique for mental map preservation of visual diagrams.},
  acmid = {3079400},
  added-at = {2018-01-30T14:59:55.000+0100},
  address = {New York, NY, USA},
  articleno = {26},
  author = {Oka, Akio and Masuhara, Hidehiko and Imai, Tomoki and Aotani, Tomoyuki},
  biburl = {https://www.bibsonomy.org/bibtex/22b0f920cd6a0f2b39e15f2713d3d40a8/gron},
  booktitle = {Companion to the First International Conference on the Art, Science and Engineering of Programming},
  description = {Live Data Structure Programming},
  doi = {10.1145/3079368.3079400},
  interhash = {df14efb866ef47a58cc6a7340d53f02e},
  intrahash = {2b0f920cd6a0f2b39e15f2713d3d40a8},
  isbn = {978-1-4503-4836-2},
  keywords = {Data LiveProgramming ProgrammingExperience Structures Visualization},
  location = {Brussels, Belgium},
  numpages = {7},
  pages = {26:1--26:7},
  publisher = {ACM},
  series = {Programming'17},
  timestamp = {2018-01-30T14:59:55.000+0100},
  title = {{Live Data Structure Programming}},
  year = 2017
}

@article{Tanimoto:1990:Viva,
  abstract = {Visual languages have been developed to help new programmers express algorithms easily. They also help to make experienced programmers more productive by simplifying the organization of a program through the use of visual representations. However, visual languages have not reached their full potential because of several problems including the following: difficulty of producing visual representations for the more abstract computing constructs; the lack of adequate computing power to update the visual representations in response to user actions; the immaturity of the subfield of visual programming and need for additional breakthroughs and standardization of existing mechanisms. Visualization of Vision Algorithms (VIVA) is a proposed visual language for image processing. Its main purpose is to serve as an effective teaching tool for students of image processing. Its design also takes account of several secondary goals, including the completion of a software platform for research in human/image interaction, the creation of a vehicle for studying algorithms and architectures for parallel image processing, and the establishment of a presentation medium for image-processing algorithms.},
  added-at = {2018-01-30T15:28:49.000+0100},
  author = {Tanimoto, Steven L.},
  biburl = {https://www.bibsonomy.org/bibtex/2251a18ed9ffc6a76bd84ec84f4f58873/gron},
  description = {VIVA: A visual language for image processing - ScienceDirect},
  doi = {https://doi.org/10.1016/S1045-926X(05)80012-6},
  interhash = {a3d1d020f91bac6ec513da7d2391be5b},
  intrahash = {251a18ed9ffc6a76bd84ec84f4f58873},
  issn = {1045-926X},
  journal = {Journal of Visual Languages \& Computing},
  keywords = {Definition Levels LiveProgramming Requirements Stages},
  number = 2,
  pages = {127 - 139},
  timestamp = {2018-01-30T15:28:49.000+0100},
  title = {{VIVA: A Visual Language for Image Processing}},
  volume = 1,
  year = 1990
}

@inproceedings{McDirmid:2007:LUL,
  acmid = {1297073},
  added-at = {2018-01-30T15:36:49.000+0100},
  address = {New York, NY, USA},
  author = {McDirmid, Sean},
  biburl = {https://www.bibsonomy.org/bibtex/2bc613b8c34303deeb9c259225f9402a8/gron},
  booktitle = {Proceedings of the 22Nd Annual ACM SIGPLAN Conference on Object-oriented Programming Systems and Applications},
  doi = {10.1145/1297027.1297073},
  interhash = {7fa6f5769cc4e86ce75e6f8dcb4143cb},
  intrahash = {bc613b8c34303deeb9c259225f9402a8},
  isbn = {978-1-59593-786-5},
  keywords = {Environment Exploration LiveProgramming},
  location = {Montreal, Quebec, Canada},
  numpages = {16},
  pages = {623--638},
  publisher = {ACM},
  series = {OOPSLA'07},
  timestamp = {2018-01-30T15:36:49.000+0100},
  title = {{Living It Up with a Live Programming Language}},
  url = {http://doi.acm.org/10.1145/1297027.1297073},
  year = 2007
}

@inproceedings{Burckhardt:2013:ACF,
  acmid = {2462170},
  added-at = {2018-01-30T15:41:23.000+0100},
  author = {Burckhardt, Sebastian and Fahndrich, Manuel and de Halleux, Peli and McDirmid, Sean and Moskal, Michal and Tillmann, Nikolai and Kato, Jun},
  biburl = {https://www.bibsonomy.org/bibtex/24a087e36937fa1fe2c976994575e3dcb/gron},
  booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi = {10.1145/2491956.2462170},
  interhash = {39d6c990f3d1fc7fde7271f2bf5ec106},
  intrahash = {4a087e36937fa1fe2c976994575e3dcb},
  isbn = {978-1-4503-2014-6},
  keywords = {LiveProgramming ProgrammingExperience UserInterface},
  location = {Seattle, Washington, USA},
  numpages = {10},
  pages = {95--104},
  publisher = {ACM},
  series = {PLDI'13},
  timestamp = {2018-01-30T15:41:23.000+0100},
  title = {{It's Alive! Continuous Feedback in UI Programming}},
  year = 2013
}

@inproceedings{Tanimoto:2013:PEL,
  abstract = {Liveness in programming environments generally refers to the ability to modify a running program. Liveness is one form of a more general class of behaviors by a programming environment that provide information to programmers about what they are constructing. This paper gives a brief historical perspective on liveness and proposes an extension of a hierarchy given in 1990, to now account for even more powerful execution-oriented tools for programmers. In addition, while liveness concerns the timeliness of execution feedback, considering a broader array of forms of feedback is helpful both in better understanding liveness and in designing ever more powerful development tools.},
  acmid = {2662735},
  added-at = {2018-01-30T18:23:00.000+0100},
  address = {Piscataway, NJ, USA},
  author = {Tanimoto, Steven L.},
  biburl = {https://www.bibsonomy.org/bibtex/2848046e30360ec0c07b821433f3199ac/gron},
  booktitle = {Proceedings of the 1st International Workshop on Live Programming},
  description = {A perspective on the evolution of live programming},
  doi = {10.1109/LIVE.2013.6617346},
  interhash = {76ecbb1c2f981acf702fd9f2dcbc2eb9},
  intrahash = {848046e30360ec0c07b821433f3199ac},
  isbn = {978-1-4673-6265-8},
  keywords = {Analysis Discussion LiveProgramming PositionPaper Requirements},
  location = {San Francisco, California},
  numpages = {4},
  pages = {31--34},
  publisher = {IEEE Press},
  series = {LIVE '13},
  timestamp = {2018-01-30T18:23:00.000+0100},
  title = {{A Perspective on the Evolution of Live Programming}},
  year = 2013
}

@incollection{Bracha:10:NS,
  added-at = {2015-09-09T09:27:03.000+0200},
  author = {Bracha, Gilad and von der Ahé, Peter and Bykov, Vassili and Kashai, Yaron and Maddox, William and Miranda, Eliot},
  biburl = {https://www.bibsonomy.org/bibtex/2119dd7762daaef98095efb24204d5f1b/gron},
  booktitle = {ECOOP 2010 – Object-Oriented Programming},
  description = {Modules as Objects in Newspeak - Springer},
  doi = {10.1007/978-3-642-14107-2_20},
  interhash = {854e691223c68a76c19d9bb12e55be6b},
  intrahash = {119dd7762daaef98095efb24204d5f1b},
  isbn = {978-3-642-14106-5},
  keywords = {Classes Lookup Modules Newspeak Structuring},
  language = {English},
  pages = {405-428},
  publisher = {Springer},
  series = {Lecture Notes in Computer Science},
  timestamp = {2015-09-09T09:27:03.000+0200},
  title = {{Modules as Objects in Newspeak}},
  volume = 6183,
  year = 2010
}

@presentation{OptCELWithTruffle,
  abstract = {Communicating Event-Loop Languages similar to E and AmbientTalk are recently gaining more traction as a subset of actor languages. With the rise of JavaScript, E’s notion of vats and non-blocking communication based on promises entered the mainstream. For implementations, the combination of dynamic typing, asynchronous message sending, and promise resolution pose new optimization challenges.

This paper discusses these challenges and presents initial experiments for a Newspeak implementation based on the Truffle framework. Our implementation is on average 1.65x slower than Java on a set of 14 benchmarks. Initial optimizations improve the performance of asynchronous messages and reduce the cost of encapsulation on microbenchmarks by about 2x. Parallel actor benchmarks further show that the system scales based on the workload characteristics. Thus, we conclude that Truffle is a promising platform also for communicating event-loop languages.},
  added-at = {2015-09-25T10:47:48.000+0200},
  author = {Marr, Stefan and Mössenböck, Hanspeter},
  biburl = {https://www.bibsonomy.org/bibtex/29f9881cc5d059f4916d4805e780b5e00/gron},
  blog = {http://stefan-marr.de/2015/10/optimizing-communicating-event-loop-languages-with-truffle/},
  booktitle = {Presentation at 5th International Workshop on Programming based on Actors, Agents, and Decentralized Control},
  day = 26,
  html = {http://stefan-marr.de/papers/agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle/},
  interhash = {0a0937a8e45344c88cbe6fb1ad8c42fa},
  intrahash = {9f9881cc5d059f4916d4805e780b5e00},
  keywords = {Actors Caching CommunicatingEventLoops Compiler Concurrency MeMyPublication Message Optimization PIC Sending Truffle myown},
  location = {Pittsburgh, PA, USA},
  month = {October},
  pdf = {http://stefan-marr.de/downloads/agere15-agere-marr-moessenboeck-optimizing-communicating-event-loop-languages-with-truffle.pdf},
  series = {AGERE '15},
  timestamp = {2017-06-06T17:35:20.000+0200},
  title = {Optimizing Communicating Event-Loop Languages with Truffle},
  type = {Work-in-Progress-Paper},
  year = 2015
}

@inproceedings{Rein:2016:LLP,
  abstract = {The idea of live programming has been applied in various domains, including the exploration of simulations, general-purpose application development, and even live performance of music. As a result, different qualitative definitions of the term live programming exist. Often, these definitions refer to a sense of "directness" or "immediacy" regarding the responses of the system. However, most of them lack quantitative thresholds of this response time. Thus, we propose a survey of live programming environments to determine common response times the community regards as sufficient. In this paper, we discuss the design of an initial survey focusing on general-purpose live programming environments. We describe the selection process of systems and the benchmarking model to measure relevant time spans. We illustrate the potential outcomes of such a study with results from applying the benchmarking model to Squeak/Smalltalk and the Self environment. The results hint that a quick adaptation of the executable form might be a common feature of live programming environments.},
  acmid = {2984381},
  added-at = {2018-01-31T10:47:47.000+0100},
  author = {Rein, Patrick and Lehmann, Stefan and Mattis, Toni and Hirschfeld, Robert},
  biburl = {https://www.bibsonomy.org/bibtex/206e53df07ed649f7f37e66a998e09c84/gron},
  booktitle = {Proceedings of the Programming Experience 2016 (PX/16) Workshop},
  description = {How Live are Live Programming Systems?},
  doi = {10.1145/2984380.2984381},
  interhash = {e21482e6fb51516f0e1768002fd9e98f},
  intrahash = {06e53df07ed649f7f37e66a998e09c84},
  isbn = {978-1-4503-4776-1},
  keywords = {Background Definitions Evaluation LiveProgramming Performance},
  location = {Rome, Italy},
  numpages = {8},
  pages = {1--8},
  publisher = {ACM},
  series = {PX/16},
  timestamp = {2018-01-31T10:47:47.000+0100},
  title = {{How Live Are Live Programming Systems?: Benchmarking the Response Times of Live Programming Environments}},
  year = 2016
}

@techreport{Cpp17,
  added-at = {2018-02-01T12:31:24.000+0100},
  author = {{ISO/IEC}},
  biburl = {https://www.bibsonomy.org/bibtex/27e36ce1307fbcb3fe8ac2b6c9ff2fea0/gron},
  interhash = {c7296cbed20a319bf09091c6185c85c0},
  intrahash = {7e36ce1307fbcb3fe8ac2b6c9ff2fea0},
  keywords = {C++ Standard},
  month = {March},
  number = {N4660},
  timestamp = {2018-02-01T12:31:24.000+0100},
  title = {Programming Languages --- C++},
  type = {Draft International Standard},
  url = {https://web.archive.org/web/20170325025026/http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4660.pdf},
  year = 2017
}

@inproceedings{Steindorfer:2015:OHM,
  acmid = {2814312},
  added-at = {2018-02-04T14:22:39.000+0100},
  address = {New York, NY, USA},
  author = {Steindorfer, Michael J. and Vinju, Jurgen J.},
  biburl = {https://www.bibsonomy.org/bibtex/220763122612db24e842421670da3c95f/gron},
  booktitle = {Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  description = {Optimizing hash-array mapped tries for fast and lean immutable JVM collections},
  doi = {10.1145/2814270.2814312},
  interhash = {e35ab80d01f274bf32ba7a6d48005eed},
  intrahash = {20763122612db24e842421670da3c95f},
  isbn = {978-1-4503-3689-5},
  keywords = {Clojure Collections Hash Immutable JVM Java Scala Tree},
  location = {Pittsburgh, PA, USA},
  numpages = {18},
  pages = {783--800},
  publisher = {ACM},
  series = {OOPSLA 2015},
  timestamp = {2018-02-04T14:22:39.000+0100},
  title = {{Optimizing Hash-array Mapped Tries for Fast and Lean Immutable JVM Collections}},
  url = {http://doi.acm.org/10.1145/2814270.2814312},
  year = 2015
}

@book{Smalltalk80,
  added-at = {2008-07-09T17:58:26.000+0200},
  address = {Boston, MA, USA},
  asin = {0201113716},
  author = {Goldberg, Adele and Robson, David},
  biburl = {https://www.bibsonomy.org/bibtex/2d0ef20b658c303d3cf61d2498e7843a8/gron},
  description = {Smalltalk-80},
  ean = {9780201113716},
  interhash = {0832b3253eb13ebb44adb047cba2ed68},
  intrahash = {d0ef20b658c303d3cf61d2498e7843a8},
  isbn = {0201113716},
  keywords = {Me:MastersThesis Smalltalk VM VirtualImage},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  timestamp = {2013-08-01T17:59:54.000+0200},
  title = {Smalltalk-80: The Language and its Implementation},
  year = 1983
}

@inproceedings{6624029,
  abstract = {The tens of thousands of high-quality open source software projects on the Internet raise the exciting possibility of studying software development by finding patterns across truly large source code repositories. This could enable new tools for developing code, encouraging reuse, and navigating large projects. In this paper, we build the first giga-token probabilistic language model of source code, based on 352 million lines of Java. This is 100 times the scale of the pioneering work by Hindle et al. The giga-token model is significantly better at the code suggestion task than previous models. More broadly, our approach provides a new &#x201C;lens&#x201D; for analyzing software projects, enabling new complexity metrics based on statistical analysis of large corpora. We call these metrics data-driven complexity metrics. We propose new metrics that measure the complexity of a code module and the topical centrality of a module to a software project. In particular, it is possible to distinguish reusable utility classes from classes that are part of a program's core logic based solely on general information theoretic criteria.},
  added-at = {2018-02-04T20:24:18.000+0100},
  author = {Allamanis, Miltiadis and Sutton, Charles A.},
  biburl = {https://www.bibsonomy.org/bibtex/2fa8a7c47497cfc09b26bb31907d0c48e/gron},
  booktitle = {10th Working Conference on Mining Software Repositories},
  description = {Mining source code repositories at massive scale using language modeling - IEEE Conference Publication},
  doi = {10.1109/MSR.2013.6624029},
  interhash = {8ced387fd39ced422cb2c8bdafbeb099},
  intrahash = {fa8a7c47497cfc09b26bb31907d0c48e},
  issn = {2160-1852},
  keywords = {Corpus GitHub Java},
  month = may,
  pages = {207--216},
  publisher = {IEEE},
  series = {MSR'13},
  timestamp = {2018-02-04T20:24:18.000+0100},
  title = {{Mining Source Code Repositories at Massive Scale using Language Modeling}},
  year = 2013
}

@article{The_implementation_of_lua,
  abstract = {We discuss the main novelties of the   implementation of Lua 5.0: its register-based virtual machine, the   new algorithm for optimizing tables used as arrays, the   implementation of closures, and the addition of   coroutines.},
  added-at = {2009-07-13T15:07:15.000+0200},
  author = {Ierusalimschy, Roberto and de Figueiredo, Luiz Henrique and Celes, Waldemar},
  biburl = {https://www.bibsonomy.org/bibtex/24de4ac073d60436b2b064dfebf91d17a/gron},
  interhash = {03881d00f72a7d5598baa95cf4398678},
  intrahash = {4de4ac073d60436b2b064dfebf91d17a},
  journal = {Journal of Universal Computer Science},
  keywords = {Language Lua VM},
  number = 7,
  pages = {1159--1176},
  timestamp = {2009-07-13T15:07:15.000+0200},
  title = {The Implementation of Lua 5.0},
  doi = {10.3217/jucs-011-07-1159},
  volume = 11,
  year = 2005
}

@inproceedings{DeWael:15:JitData,
  abstract = {Today, software engineering practices focus on finding the single right data representation (i.e., data structure) for a program. The right data representation, however, might not exist: relying on a single representation of the data for the lifetime of the program can be suboptimal in terms of performance. We explore the idea of developing data structures for which changing the data representation is an intrinsic property. To this end we introduce Just-in-Time Data Structures, which enable representation changes at runtime, based on declarative input from a performance expert programmer. Just-in-Time Data Structures are an attempt to shift the focus from finding the ``right’’ data structure to finding the right sequence of data representations. We present JitDS-Java, an extension to the Java language, to develop Just-in-Time Data Structures. Further, we show two example programs that benefit from changing the representation at runtime.},
  added-at = {2015-09-25T12:10:59.000+0200},
  author = {De Wael, Mattias and Marr, Stefan and De Koster, Joeri and Sartor, Jennifer B. and De Meuter, Wolfgang},
  biburl = {https://www.bibsonomy.org/bibtex/2889bbc4c57b61960cdfb2a93147bce23/gron},
  blog = {http://stefan-marr.de/2015/10/jit-data-structures-fully-reflective-vms-and-meta-circular-meta-tracing/},
  booktitle = {Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
  doi = {10.1145/2814228.2814231},
  interhash = {ca767ff263c76e39ba25305e658771f5},
  intrahash = {889bbc4c57b61960cdfb2a93147bce23},
  isbn = {978-1-4503-3688-8},
  keywords = {Algorithms DataStructures DynamicReclassification MeMyPublication Optimizations Performance myown},
  month = {October},
  numpages = {15},
  pages = {61--75},
  pdf = {http://stefan-marr.de/downloads/onward15-de-wael-et-al-just-in-time-data-structures.pdf},
  publisher = {ACM},
  series = {Onward!'15},
  timestamp = {2017-06-06T17:52:47.000+0200},
  title = {Just-in-Time Data Structures},
  year = 2015
}

@inproceedings{Costa:2018:CS,
  added-at = {2018-02-07T18:18:41.000+0100},
  author = {Costa, Diego and Andrzejak, Artur},
  biburl = {https://www.bibsonomy.org/bibtex/2c9a566d1edb3d6f40f963188842e02ce/gron},
  booktitle = {Proceedings of 2018 IEEE/ACM International Symposium on Code Generation and Optimization},
  day = {24--28},
  doi = {10.1145/3168825},
  interhash = {c56d1eab2e8e1a0b316570fa5a6cbb31},
  intrahash = {c9a566d1edb3d6f40f963188842e02ce},
  keywords = {Adaptive DataStructures Dynamic JustInTime Optimization Performance collections},
  month = {February},
  pages = {16--26},
  series = {CGO'18},
  timestamp = {2018-02-07T18:18:41.000+0100},
  title = {{CollectionSwitch: A Framework for Efficient and Dynamic Collection Selection}},
  url = {http://pvs.ifi.uni-heidelberg.de/fileadmin/papers/2018/Collectionswitch_-_CGO2018.pdf},
  year = 2018
}

@inproceedings{Xu2013,
  added-at = {2016-10-20T17:37:58.000+0200},
  author = {Xu, Guoqing},
  biburl = {https://www.bibsonomy.org/bibtex/21080ddcc5d8f48c5f02d2e0c5baff873/gron},
  booktitle = {ECOOP 2013 -- Object-Oriented Programming: 27th European Conference, Montpellier, France, July 1-5, 2013. Proceedings},
  description = {CoCo: Sound and Adaptive Replacement of Java Collections - Springer},
  doi = {10.1007/978-3-642-39038-8_1},
  editor = {Castagna, Giuseppe},
  interhash = {6e0a19c3c5562f4b1d6caeaa268fc225},
  intrahash = {1080ddcc5d8f48c5f02d2e0c5baff873},
  isbn = {978-3-642-39038-8},
  keywords = {Collections DataStructures JIT Optimizations},
  pages = {1--26},
  publisher = {Springer},
  timestamp = {2016-10-20T17:37:58.000+0200},
  title = {{CoCo: Sound and Adaptive Replacement of Java Collections}},
  year = 2013
}

@article{Pape:2017:VC,
  abstract = {The performance of value classes is highly dependent on how they are represented in the virtual machine. Value class instances are immutable, have no identity, and can only refer to other value objects or primitive values and since they should be very lightweight and fast, it is important to optimize them carefully. In this paper we present a technique to detect and compress common patterns of value class usage to improve memory usage and performance. The technique identifies patterns of frequent value object references and introduces abbreviated forms for them. This allows to store multiple inter-referenced value objects in an inlined memory representation, reducing the overhead stemming from meta-data and object references. Applied to a small prototype and an implementation of the Racket language, we found improvements in memory usage and execution time for several micro-benchmarks.},
  added-at = {2018-02-07T18:28:13.000+0100},
  author = {Pape, Tobias and Bolz, Carl Friedrich and Hirschfeld, Robert},
  biburl = {https://www.bibsonomy.org/bibtex/2eec2aeabc8d2996d9a6dc3d08bc1913e/gron},
  description = {Adaptive just-in-time value class optimization for lowering memory consumption and improving execution time performance - ScienceDirect},
  doi = {10.1016/j.scico.2016.08.003},
  interhash = {5ad04ffaaf79ae3dff83c785f6da088d},
  intrahash = {eec2aeabc8d2996d9a6dc3d08bc1913e},
  issn = {0167-6423},
  journal = {Science of Computer Programming},
  keywords = {DataStructures Immutability Value},
  pages = {17--29},
  timestamp = {2018-02-07T18:28:13.000+0100},
  title = {{Adaptive Just-in-time Value Class Optimization for Lowering Memory Consumption and Improving Execution Time Performance}},
  volume = 140,
  year = 2017
}

@inproceedings{Daloze:2016:TSO,
  abstract = {We are in the multi-core era.
Dynamically-typed languages are in widespread use, but their support for
multithreading still lags behind. One of the reasons is that the sophisticated
techniques they use to efficiently represent their dynamic object models are
often unsafe in multithreaded environments.

This paper defines safety requirements for dynamic object models in
multithreaded environments.
Based on these requirements, a language-agnostic and thread-safe object model
is designed that maintains the efficiency of sequential approaches.
This is achieved by ensuring that field reads do not require synchronization
and field updates only need to synchronize on objects shared between threads.

Basing our work on JRuby+Truffle, we show that our safe object model has zero overhead on peak performance for thread-local objects
and only 3\% average overhead on parallel benchmarks where field updates require synchronization.
Thus, it can be a foundation for safe and efficient multithreaded VMs for a wide range of dynamic languages.},
  acceptancerate = {0.25},
  added-at = {2016-08-06T18:36:38.000+0200},
  author = {Daloze, Benoit and Marr, Stefan and Bonetta, Daniele and Mössenböck, Hanspeter},
  biburl = {https://www.bibsonomy.org/bibtex/262830f65bdc9a0a1046a41c0aee771e4/gron},
  booktitle = {Proceedings of the 2016 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
  day = 2,
  doi = {10.1145/2983990.2984001},
  interhash = {e308e02d9e1ea4c4e8187c56cd3770e8},
  intrahash = {62830f65bdc9a0a1046a41c0aee771e4},
  isbn = {978-1-4503-4444-9},
  keywords = {Bugs Concurrency HiddenClasses JRuby Map MeMyPublication ObjectModel ObjectStorage RaceConditions Ruby ThreadSafety myown},
  month = {November},
  numpages = {18},
  pages = {642--659},
  pdf = {http://stefan-marr.de/downloads/oopsla16-daloze-et-al-efficient-and-thread-safe-objects-for-dynamically-typed-languages.pdf},
  publisher = {ACM},
  series = {OOPSLA'16},
  timestamp = {2017-06-06T00:23:12.000+0200},
  title = {{Efficient and Thread-Safe Objects for Dynamically-Typed Languages}},
  year = 2016
}

@inproceedings{Clifford:2015:MMD,
  added-at = {2017-04-02T16:31:26.000+0200},
  author = {Clifford, Daniel and Payer, Hannes and Stanton, Michael and Titzer, Ben L.},
  biburl = {https://www.bibsonomy.org/bibtex/20a26f807a6cb87373bd4ee4d577672f7/gron},
  booktitle = {Proceedings of the 2015 International Symposium on Memory Management},
  doi = {10.1145/2754169.2754181},
  interhash = {e8053e5d7f1c70dbf02aaa85874bb3bc},
  intrahash = {0a26f807a6cb87373bd4ee4d577672f7},
  isbn = {978-1-4503-3589-8},
  keywords = {Collection Dynamic JavaScript Management Memory Optimization V8},
  location = {Portland, OR, USA},
  numpages = {13},
  pages = {105--117},
  publisher = {ACM},
  series = {ISMM'15},
  timestamp = {2017-04-02T16:31:26.000+0200},
  title = {{Memento Mori: Dynamic Allocation-site-based Optimizations}},
  year = 2015
}
